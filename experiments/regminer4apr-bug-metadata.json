{
    "1_src/main/java/com/adobe/epubcheck/ctc/css/EpubCSSCheckCSSHandler.java": {
        "context": "  void CheckFontSize(CssGrammar.CssConstruct construct, CssGrammar.CssDeclaration declaration)\n  {\n    MessageId id = hasIndividualFixedFormatDocuments ? MessageId.ACC_016 : MessageId.ACC_014;\n    switch (construct.getType())\n    {\n      case KEYWORD:\n      {\n        if (!isGlobalFixedFormat || hasIndividualFixedFormatDocuments)\n        {\n          // report non-relative font-size keyword as ACC USAGE message\n          String value = construct.toCssString().toLowerCase(Locale.ROOT);\n\n          // report not allowed font-size keyword as ERROR message\n          if (!isFontSize(construct))\n          {\n            getReport().message(MessageId.CSS_020, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n          }\n          else if ((\"smaller\".compareTo(value) != 0) && (\"larger\".compareTo(value) != 0) && (\"inherit\".compareTo(value) != 0))\n          {\n            getReport().message(id, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n          }\n          \n        }\n        break;\n      }\n      case QUANTITY:\n        if (!isGlobalFixedFormat || hasIndividualFixedFormatDocuments)\n        {\n          CssGrammar.CssQuantity quantity = (CssGrammar.CssQuantity) construct;\n          switch (quantity.getUnit())\n          {\n            case EMS:\n            case EXS:\n            case REMS:\n            case PERCENTAGE:\n              break;\n            case LENGTH:\n              // report absolute font-size as ACC USAGE message\n              getReport().message(id, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n              break;\n            default:\n              // report unsupported font-size as ERROR message\n              getReport().message(MessageId.CSS_020, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n              break;\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  }\n",
        "start_line": 585,
        "end_line": 585,
        "bug_id": "1",
        "before": "  void CheckFontSize(CssGrammar.CssConstruct construct, CssGrammar.CssDeclaration declaration)\n  {\n    MessageId id = hasIndividualFixedFormatDocuments ? MessageId.ACC_016 : MessageId.ACC_014;\n    switch (construct.getType())\n    {\n      case KEYWORD:\n      {\n        if (!isGlobalFixedFormat || hasIndividualFixedFormatDocuments)\n        {\n          // report non-relative font-size keyword as ACC USAGE message\n          String value = construct.toCssString().toLowerCase(Locale.ROOT);\n\n          // report not allowed font-size keyword as ERROR message\n          if (!isFontSize(construct))\n          {\n            getReport().message(MessageId.CSS_020, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n          }\n          else if ((\"smaller\".compareTo(value) != 0) && (\"larger\".compareTo(value) != 0) && (\"inherit\".compareTo(value) != 0))\n          {\n            getReport().message(id, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n          }\n          \n        }\n        break;\n      }\n      case QUANTITY:\n        if (!isGlobalFixedFormat || hasIndividualFixedFormatDocuments)\n        {\n          CssGrammar.CssQuantity quantity = (CssGrammar.CssQuantity) construct;\n          switch (quantity.getUnit())\n          {\n            case EMS:\n            case EXS:\n            case REMS:\n            case PERCENTAGE:\n              break;\n            case LENGTH:\n              // report absolute font-size as ACC USAGE message\n              getReport().message(id, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n              break;\n",
        "after": "            default:\n              // report unsupported font-size as ERROR message\n              getReport().message(MessageId.CSS_020, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n              break;\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  }\n",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 545,
        "method_end_line": 596
    },
    "2_src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java": {
        "context": "  private void readUntilEndOfEntry() throws IOException {\n    if (localFileHeader.isDirectory() || localFileHeader.getCompressedSize() == 0) {\n      return;\n    }\n\n    if (endOfEntryBuffer == null) {\n      endOfEntryBuffer = new byte[512];\n    }\n\n    while (read(endOfEntryBuffer) != -1);\n  }\n",
        "start_line": 306,
        "end_line": 307,
        "bug_id": "2",
        "before": "  private void readUntilEndOfEntry() throws IOException {\n",
        "after": "      return;\n    }\n\n    if (endOfEntryBuffer == null) {\n      endOfEntryBuffer = new byte[512];\n    }\n\n    while (read(endOfEntryBuffer) != -1);\n  }\n",
        "buggy_line": "if (localFileHeader.isDirectory() || localFileHeader.getCompressedSize() == 0) {",
        "buggy_lines": "    if (localFileHeader.isDirectory() || localFileHeader.getCompressedSize() == 0) {\n",
        "method_start_line": 305,
        "method_end_line": 316
    },
    "3_src/main/java/org/logicng/formulas/FormulaFactory.java": {
        "context": "  public Formula implication(final Formula left, final Formula right) {\n    if (left.type() == FALSE || right.type() == TRUE)\n      return this.verum();\n    if (left.type() == TRUE)\n      return right;\n    if (right.type() == FALSE)\n      return this.not(left);\n    if (left.equals(right))\n      return this.verum();\n    if (left.negate().equals(right))\n      return left.negate();\n    final Pair<Formula, Formula> key = new Pair<>(left, right);\n    Implication implication = this.implications.get(key);\n    if (implication == null) {\n      implication = new Implication(left, right, this);\n      this.implications.put(key, implication);\n    }\n    return implication;\n  }\n",
        "start_line": 281,
        "end_line": 283,
        "bug_id": "3",
        "before": "  public Formula implication(final Formula left, final Formula right) {\n    if (left.type() == FALSE || right.type() == TRUE)\n      return this.verum();\n    if (left.type() == TRUE)\n      return right;\n    if (right.type() == FALSE)\n      return this.not(left);\n    if (left.equals(right))\n      return this.verum();\n",
        "after": "    final Pair<Formula, Formula> key = new Pair<>(left, right);\n    Implication implication = this.implications.get(key);\n    if (implication == null) {\n      implication = new Implication(left, right, this);\n      this.implications.put(key, implication);\n    }\n    return implication;\n  }\n",
        "buggy_line": "if (left.negate().equals(right))      return left.negate();",
        "buggy_lines": "    if (left.negate().equals(right))\n      return left.negate();\n",
        "method_start_line": 272,
        "method_end_line": 291
    },
    "5_src/main/java/hudson/tasks/junit/CaseResult.java": {
        "context": "    @Exported(visibility=999)\n    public @Override String getName() {\n    \tif (testName.isEmpty()) {\n    \t\treturn \"(?)\";\n    \t}\n        return testName;\n    }\n",
        "start_line": 323,
        "end_line": 324,
        "bug_id": "5",
        "before": "    @Exported(visibility=999)\n    public @Override String getName() {\n",
        "after": "    \t\treturn \"(?)\";\n    \t}\n        return testName;\n    }\n",
        "buggy_line": "if (testName.isEmpty()) {",
        "buggy_lines": "    \tif (testName.isEmpty()) {\n",
        "method_start_line": 321,
        "method_end_line": 328
    },
    "10_src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java": {
        "context": "\tprivate static boolean isAssignableFrom(Class<?> target, KType source) {\n\n\t\tType parameterType = ReflectJvmMapping.getJavaType(source);\n\n\t\treturn ResolvableType.forClass(target).isAssignableFrom(ResolvableType.forType(parameterType));\n\t}\n",
        "start_line": 281,
        "end_line": 282,
        "bug_id": "10",
        "before": "\tprivate static boolean isAssignableFrom(Class<?> target, KType source) {\n\n\t\tType parameterType = ReflectJvmMapping.getJavaType(source);\n\n",
        "after": "\t}\n",
        "buggy_line": "return ResolvableType.forClass(target).isAssignableFrom(ResolvableType.forType(parameterType));",
        "buggy_lines": "\t\treturn ResolvableType.forClass(target).isAssignableFrom(ResolvableType.forType(parameterType));\n",
        "method_start_line": 277,
        "method_end_line": 283
    },
    "12_src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java": {
        "context": "    private YamlNode valueOfStringKey(final String key) {\n        YamlNode value = null;\n        final String[] keys = new String[] {\n            key,\n            \"\\\"\" + key + \"\\\"\",\n            \"'\" + key + \"'\",\n        };\n        for(final String tryKey : keys) {\n            for (final YamlLine line : this.significant) {\n                final String trimmed = line.trimmed();\n                if(trimmed.endsWith(tryKey + \":\")\n                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\>$\")\n                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\|$\")\n                ) {\n                    value = this.significant.toYamlNode(\n                        line, this.guessIndentation\n                    );\n                } else if((trimmed.startsWith(tryKey + \":\")\n                    || trimmed.startsWith(\"- \" + tryKey + \":\"))\n                    && trimmed.length() > 1\n                ) {\n                    value = new ReadPlainScalar(this.all, line);\n                }\n                if(value != null) {\n                    return value;\n                }\n            }\n        }\n        return null;\n    }\n",
        "start_line": 241,
        "end_line": 242,
        "bug_id": "12",
        "before": "    private YamlNode valueOfStringKey(final String key) {\n        YamlNode value = null;\n        final String[] keys = new String[] {\n            key,\n            \"\\\"\" + key + \"\\\"\",\n            \"'\" + key + \"'\",\n        };\n        for(final String tryKey : keys) {\n            for (final YamlLine line : this.significant) {\n                final String trimmed = line.trimmed();\n",
        "after": "                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\>$\")\n                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\|$\")\n                ) {\n                    value = this.significant.toYamlNode(\n                        line, this.guessIndentation\n                    );\n                } else if((trimmed.startsWith(tryKey + \":\")\n                    || trimmed.startsWith(\"- \" + tryKey + \":\"))\n                    && trimmed.length() > 1\n                ) {\n                    value = new ReadPlainScalar(this.all, line);\n                }\n                if(value != null) {\n                    return value;\n                }\n            }\n        }\n        return null;\n    }\n",
        "buggy_line": "if(trimmed.endsWith(tryKey + \":\")",
        "buggy_lines": "                if(trimmed.endsWith(tryKey + \":\")\n",
        "method_start_line": 231,
        "method_end_line": 261
    },
    "13_src/main/java/com/amihaiemil/eoyaml/ReadYamlMapping.java": {
        "context": "    private YamlNode valueOfStringKey(final String key) {\n        YamlNode value = null;\n        final String[] keys = new String[] {\n            key,\n            \"\\\"\" + key + \"\\\"\",\n            \"'\" + key + \"'\",\n        };\n        for(final String tryKey : keys) {\n            for (final YamlLine line : this.significant) {\n                final String trimmed = line.trimmed();\n                if(trimmed.endsWith(tryKey + \":\")\n                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\>$\")\n                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\|$\")\n                ) {\n                    value = this.significant.toYamlNode(\n                        line, this.guessIndentation\n                    );\n                } else if((trimmed.startsWith(tryKey + \":\")\n                    || trimmed.startsWith(\"- \" + tryKey + \":\"))\n                    && trimmed.length() > 1\n                ) {\n                    value = new ReadPlainScalar(this.all, line);\n                }\n                if(value != null) {\n                    return value;\n                }\n            }\n        }\n        return null;\n    }\n",
        "start_line": 241,
        "end_line": 242,
        "bug_id": "13",
        "before": "    private YamlNode valueOfStringKey(final String key) {\n        YamlNode value = null;\n        final String[] keys = new String[] {\n            key,\n            \"\\\"\" + key + \"\\\"\",\n            \"'\" + key + \"'\",\n        };\n        for(final String tryKey : keys) {\n            for (final YamlLine line : this.significant) {\n                final String trimmed = line.trimmed();\n",
        "after": "                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\>$\")\n                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\|$\")\n                ) {\n                    value = this.significant.toYamlNode(\n                        line, this.guessIndentation\n                    );\n                } else if((trimmed.startsWith(tryKey + \":\")\n                    || trimmed.startsWith(\"- \" + tryKey + \":\"))\n                    && trimmed.length() > 1\n                ) {\n                    value = new ReadPlainScalar(this.all, line);\n                }\n                if(value != null) {\n                    return value;\n                }\n            }\n        }\n        return null;\n    }\n",
        "buggy_line": "if(trimmed.endsWith(tryKey + \":\")",
        "buggy_lines": "                if(trimmed.endsWith(tryKey + \":\")\n",
        "method_start_line": 231,
        "method_end_line": 261
    },
    "17_src/main/java/com/alibaba/fastjson/JSONPath.java": {
        "context": "    @SuppressWarnings(\"rawtypes\")\n    protected Object getArrayItem(final Object currentObject, int index) {\n        if (currentObject == null) {\n            return null;\n        }\n\n        if (currentObject instanceof List) {\n            List list = (List) currentObject;\n\n            if (index >= 0) {\n                if (index < list.size()) {\n                    return list.get(index);\n                }\n                return null;\n            } else {\n                if (Math.abs(index) <= list.size()) {\n                    return list.get(list.size() + index);\n                }\n                return null;\n            }\n        }\n\n        if (currentObject.getClass().isArray()) {\n            int arrayLenth = Array.getLength(currentObject);\n\n            if (index >= 0) {\n                if (index < arrayLenth) {\n                    return Array.get(currentObject, index);\n                }\n                return null;\n            } else {\n                if (Math.abs(index) <= arrayLenth) {\n                    return Array.get(currentObject, arrayLenth + index);\n                }\n                return null;\n            }\n        }\n\n        if (currentObject instanceof Map) {\n            Map map = (Map) currentObject;\n            Object value = map.get(index);\n            if (value == null) {\n                value = map.get(Integer.toString(index));\n            }\n            return value;\n        }\n\n        if (currentObject instanceof Collection) {\n            Collection collection = (Collection) currentObject;\n            int i = 0;\n            for (Object item : collection) {\n                if (i == index) {\n                    return item;\n                }\n                i++;\n            }\n            return null;\n        }\n\n        throw new UnsupportedOperationException();\n    }\n",
        "start_line": 3304,
        "end_line": 3304,
        "bug_id": "17",
        "before": "    @SuppressWarnings(\"rawtypes\")\n    protected Object getArrayItem(final Object currentObject, int index) {\n        if (currentObject == null) {\n            return null;\n        }\n\n        if (currentObject instanceof List) {\n            List list = (List) currentObject;\n\n            if (index >= 0) {\n                if (index < list.size()) {\n                    return list.get(index);\n                }\n                return null;\n            } else {\n                if (Math.abs(index) <= list.size()) {\n                    return list.get(list.size() + index);\n                }\n                return null;\n            }\n        }\n\n        if (currentObject.getClass().isArray()) {\n            int arrayLenth = Array.getLength(currentObject);\n\n            if (index >= 0) {\n                if (index < arrayLenth) {\n                    return Array.get(currentObject, index);\n                }\n                return null;\n            } else {\n                if (Math.abs(index) <= arrayLenth) {\n                    return Array.get(currentObject, arrayLenth + index);\n                }\n                return null;\n            }\n        }\n\n        if (currentObject instanceof Map) {\n            Map map = (Map) currentObject;\n            Object value = map.get(index);\n            if (value == null) {\n                value = map.get(Integer.toString(index));\n            }\n            return value;\n        }\n\n        if (currentObject instanceof Collection) {\n            Collection collection = (Collection) currentObject;\n            int i = 0;\n            for (Object item : collection) {\n                if (i == index) {\n                    return item;\n                }\n                i++;\n            }\n            return null;\n        }\n\n",
        "after": "        throw new UnsupportedOperationException();\n    }\n",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 3245,
        "method_end_line": 3306
    },
    "21_src/main/java/com/alibaba/druid/sql/parser/SQLExprParser.java": {
        "context": "    public SQLExpr orRest(SQLExpr expr) {\n        for (;;) {\n            if (lexer.token == Token.OR) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                if (lexer.token == Token.OR\n                        && lexer.isEnabled(SQLParserFeature.EnableSQLBinaryOpExprGroup)) {\n\n                    SQLBinaryOpExprGroup group = new SQLBinaryOpExprGroup(SQLBinaryOperator.BooleanOr, dbType);\n                    group.add(expr);\n                    group.add(rightExp);\n\n                    if (lexer.isKeepComments() && lexer.hasComment()) {\n                        rightExp.addAfterComment(lexer.readAndResetComments());\n                    }\n\n                    for (;;) {\n                        lexer.nextToken();\n                        SQLExpr more = relational();\n                        group.add(more);\n                        if (lexer.token == Token.OR) {\n                            if (lexer.isKeepComments() && lexer.hasComment()) {\n                                more.addAfterComment(lexer.readAndResetComments());\n                            }\n\n                            continue;\n                        }\n                        break;\n                    }\n\n                    expr = group;\n                } else {\n                    expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanOr, rightExp, dbType);\n                }\n            } else  if (lexer.token == Token.BARBAR && JdbcConstants.MYSQL.equals(dbType)) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanOr, rightExp, dbType);\n            } else if (lexer.token == Token.XOR) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanXor, rightExp, dbType);\n            } else {\n                break;\n            }\n        }\n\n        return expr;\n    }\n",
        "start_line": 1978,
        "end_line": 1979,
        "bug_id": "21",
        "before": "    public SQLExpr orRest(SQLExpr expr) {\n        for (;;) {\n            if (lexer.token == Token.OR) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                if (lexer.token == Token.OR\n                        && lexer.isEnabled(SQLParserFeature.EnableSQLBinaryOpExprGroup)) {\n\n                    SQLBinaryOpExprGroup group = new SQLBinaryOpExprGroup(SQLBinaryOperator.BooleanOr, dbType);\n                    group.add(expr);\n                    group.add(rightExp);\n\n                    if (lexer.isKeepComments() && lexer.hasComment()) {\n                        rightExp.addAfterComment(lexer.readAndResetComments());\n                    }\n\n                    for (;;) {\n                        lexer.nextToken();\n",
        "after": "                        group.add(more);\n                        if (lexer.token == Token.OR) {\n                            if (lexer.isKeepComments() && lexer.hasComment()) {\n                                more.addAfterComment(lexer.readAndResetComments());\n                            }\n\n                            continue;\n                        }\n                        break;\n                    }\n\n                    expr = group;\n                } else {\n                    expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanOr, rightExp, dbType);\n                }\n            } else  if (lexer.token == Token.BARBAR && JdbcConstants.MYSQL.equals(dbType)) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanOr, rightExp, dbType);\n            } else if (lexer.token == Token.XOR) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanXor, rightExp, dbType);\n            } else {\n                break;\n            }\n        }\n\n        return expr;\n    }\n",
        "buggy_line": "SQLExpr more = relational();",
        "buggy_lines": "                        SQLExpr more = relational();\n",
        "method_start_line": 1959,
        "method_end_line": 2011
    },
    "22_src/main/java/com/alibaba/druid/sql/visitor/SQLASTOutputVisitor.java": {
        "context": "    protected void printInteger(SQLIntegerExpr x, boolean parameterized) {\n        long val = x.getNumber().longValue();\n\n        if (val == 1) {\n            if (JdbcConstants.ORACLE.equals(dbType)) {\n                SQLObject parent = x.getParent();\n                if (parent instanceof SQLBinaryOpExpr) {\n                    SQLBinaryOpExpr binaryOpExpr = (SQLBinaryOpExpr) parent;\n                    SQLExpr left = binaryOpExpr.getLeft();\n                    SQLBinaryOperator op = binaryOpExpr.getOperator();\n                    if (left instanceof SQLIdentifierExpr\n                            && op == SQLBinaryOperator.Equality) {\n                        String name = ((SQLIdentifierExpr) left).getName();\n                        if (\"rownum\".equals(name)) {\n                            print(1);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        if (parameterized) {\n            print('?');\n            incrementReplaceCunt();\n\n            if(this.parameters != null){\n                ExportParameterVisitorUtils.exportParameter(this.parameters, x);\n            }\n            return;\n        }\n\n        print(val);\n    }\n",
        "start_line": 1330,
        "end_line": 1333,
        "bug_id": "22",
        "before": "    protected void printInteger(SQLIntegerExpr x, boolean parameterized) {\n",
        "after": "            if (JdbcConstants.ORACLE.equals(dbType)) {\n                SQLObject parent = x.getParent();\n                if (parent instanceof SQLBinaryOpExpr) {\n                    SQLBinaryOpExpr binaryOpExpr = (SQLBinaryOpExpr) parent;\n                    SQLExpr left = binaryOpExpr.getLeft();\n                    SQLBinaryOperator op = binaryOpExpr.getOperator();\n                    if (left instanceof SQLIdentifierExpr\n                            && op == SQLBinaryOperator.Equality) {\n                        String name = ((SQLIdentifierExpr) left).getName();\n                        if (\"rownum\".equals(name)) {\n                            print(1);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        if (parameterized) {\n            print('?');\n            incrementReplaceCunt();\n\n            if(this.parameters != null){\n                ExportParameterVisitorUtils.exportParameter(this.parameters, x);\n            }\n            return;\n        }\n\n        print(val);\n    }\n",
        "buggy_line": "long val = x.getNumber().longValue();        if (val == 1) {",
        "buggy_lines": "        long val = x.getNumber().longValue();\n\n        if (val == 1) {\n",
        "method_start_line": 1329,
        "method_end_line": 1362
    },
    "24_src/main/java/org/cactoos/io/TeeInputStream.java": {
        "context": "    public void close() throws IOException {\n        this.input.close();\n        this.output.close();\n    }\n",
        "start_line": 99,
        "end_line": 100,
        "bug_id": "24",
        "before": "    public void close() throws IOException {\n        this.input.close();\n",
        "after": "    }\n",
        "buggy_line": "this.output.close();",
        "buggy_lines": "        this.output.close();\n",
        "method_start_line": 96,
        "method_end_line": 101
    },
    "25_src/main/java/org/cactoos/collection/CollectionEnvelope.java": {
        "context": "    public final boolean equals(final Object other) {\n        return new UncheckedScalar<>(\n            new And(\n                new Or(\n                    () -> new InheritanceLevel(\n                        other.getClass(), Collection.class\n                    ).value() > -1,\n                    () -> new InheritanceLevel(\n                        other.getClass(), CollectionEnvelope.class\n                    ).value() > -1\n                ),\n                () -> {\n                    final Collection<?> compared = (Collection<?>) other;\n                    return this.size() == compared.size();\n                },\n                () -> {\n                    final Iterable<?> compared = (Iterable<?>) other;\n                    final Iterator<?> iterator = compared.iterator();\n                    return new UncheckedScalar<>(\n                        new And(\n                            (X input) -> input.equals(iterator.next()),\n                            this\n                        )\n                    ).value();\n                }\n            )\n        ).value();\n    }\n",
        "start_line": 154,
        "end_line": 162,
        "bug_id": "25",
        "before": "    public final boolean equals(final Object other) {\n        return new UncheckedScalar<>(\n            new And(\n",
        "after": "                () -> {\n                    final Collection<?> compared = (Collection<?>) other;\n                    return this.size() == compared.size();\n                },\n                () -> {\n                    final Iterable<?> compared = (Iterable<?>) other;\n                    final Iterator<?> iterator = compared.iterator();\n                    return new UncheckedScalar<>(\n                        new And(\n                            (X input) -> input.equals(iterator.next()),\n                            this\n                        )\n                    ).value();\n                }\n            )\n        ).value();\n    }\n",
        "buggy_line": "new Or(                    () -> new InheritanceLevel(                        other.getClass(), Collection.class                    ).value() > -1,                    () -> new InheritanceLevel(                        other.getClass(), CollectionEnvelope.class                    ).value() > -1                ),",
        "buggy_lines": "                new Or(\n                    () -> new InheritanceLevel(\n                        other.getClass(), Collection.class\n                    ).value() > -1,\n                    () -> new InheritanceLevel(\n                        other.getClass(), CollectionEnvelope.class\n                    ).value() > -1\n                ),\n",
        "method_start_line": 150,
        "method_end_line": 179
    },
    "28_src/main/java/com/univocity/parsers/common/ParserOutput.java": {
        "context": "\tfinal void reset() {\n\t\tthis.columnsToExtractInitialized = false;\n\t\tthis.currentRecord = 0;\n\t\tthis.column = 0;\n\t\tthis.headers = null;\n\t}\n",
        "start_line": 402,
        "end_line": 402,
        "bug_id": "28",
        "before": "\tfinal void reset() {\n\t\tthis.columnsToExtractInitialized = false;\n\t\tthis.currentRecord = 0;\n\t\tthis.column = 0;\n\t\tthis.headers = null;\n",
        "after": "\t}\n",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 397,
        "method_end_line": 403
    },
    "30_src/main/java/com/univocity/parsers/common/ParserOutput.java": {
        "context": "\tpublic String[] rowParsed() {\n\t\t// some values were parsed. Let's return them\n\t\tif (column > 0) {\n\t\t\t// identifies selected columns and headers (in the first non-empty row)\n\t\t\tif (!columnsToExtractInitialized) {\n\t\t\t\tinitializeHeaders();\n\t\t\t\t//skips the header row. We want to use the headers defined in the settings.\n\t\t\t\tif (settings.isHeaderExtractionEnabled()) {\n\t\t\t\t\tArrays.fill(parsedValues, null);\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\tthis.appender = appenders[0];\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (!columnsReordered && selectedIndexes != null) {\n\t\t\t\t\tString[] out = new String[column];\n\t\t\t\t\tfor (int i = 0; i < selectedIndexes.length; i++) {\n\t\t\t\t\t\tint index = selectedIndexes[i];\n\t\t\t\t\t\tif (index < column) {\n\t\t\t\t\t\t\tout[index] = parsedValues[index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\treturn out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentRecord++;\n\t\t\tif (columnsReordered) {\n\t\t\t\tif(selectedIndexes.length == 0){\n\t\t\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t\t\t}\n\t\t\t\tString[] reorderedValues = new String[selectedIndexes.length];\n\t\t\t\tfor (int i = 0; i < selectedIndexes.length; i++) {\n\t\t\t\t\tint index = selectedIndexes[i];\n\t\t\t\t\tif (index >= column || index == -1) {\n\t\t\t\t\t\treorderedValues[i] = nullValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treorderedValues[i] = parsedValues[index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcolumn = 0;\n\t\t\t\tthis.appender = appenders[0];\n\t\t\t\treturn reorderedValues;\n\t\t\t} else {\n\t\t\t\tint last = columnReorderingEnabledSetting ? column : column < headers.length ? headers.length : column;\n\n\t\t\t\tString[] out = new String[last];\n\t\t\t\tSystem.arraycopy(parsedValues, 0, out, 0, column);\n\t\t\t\tcolumn = 0;\n\t\t\t\tthis.appender = appenders[0];\n\t\t\t\treturn out;\n\t\t\t}\n\t\t} else if (!skipEmptyLines) { //no values were parsed, but we are not skipping empty lines\n\t\t\tif (!columnsToExtractInitialized) {\n\t\t\t\tinitializeHeaders();\n\t\t\t}\n\n\t\t\tcurrentRecord++;\n\n\t\t\tif (columnsReordered) {\n\t\t\t\tif(selectedIndexes.length == 0){\n\t\t\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t\t\t}\n\t\t\t\tString[] out = new String[selectedIndexes.length];\n\t\t\t\tArrays.fill(out, nullValue);\n\t\t\t\treturn out;\n\t\t\t}\n\n\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t}\n\t\t// no values were parsed and we do not care about empty lines.\n\t\treturn null;\n\t}\n",
        "start_line": 182,
        "end_line": 182,
        "bug_id": "30",
        "before": "\tpublic String[] rowParsed() {\n\t\t// some values were parsed. Let's return them\n\t\tif (column > 0) {\n\t\t\t// identifies selected columns and headers (in the first non-empty row)\n\t\t\tif (!columnsToExtractInitialized) {\n\t\t\t\tinitializeHeaders();\n\t\t\t\t//skips the header row. We want to use the headers defined in the settings.\n\t\t\t\tif (settings.isHeaderExtractionEnabled()) {\n\t\t\t\t\tArrays.fill(parsedValues, null);\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\tthis.appender = appenders[0];\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (!columnsReordered && selectedIndexes != null) {\n\t\t\t\t\tString[] out = new String[column];\n\t\t\t\t\tfor (int i = 0; i < selectedIndexes.length; i++) {\n\t\t\t\t\t\tint index = selectedIndexes[i];\n\t\t\t\t\t\tif (index < column) {\n\t\t\t\t\t\t\tout[index] = parsedValues[index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\treturn out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentRecord++;\n\t\t\tif (columnsReordered) {\n\t\t\t\tif(selectedIndexes.length == 0){\n",
        "after": "\t\t\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t\t\t}\n\t\t\t\tString[] reorderedValues = new String[selectedIndexes.length];\n\t\t\t\tfor (int i = 0; i < selectedIndexes.length; i++) {\n\t\t\t\t\tint index = selectedIndexes[i];\n\t\t\t\t\tif (index >= column || index == -1) {\n\t\t\t\t\t\treorderedValues[i] = nullValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treorderedValues[i] = parsedValues[index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcolumn = 0;\n\t\t\t\tthis.appender = appenders[0];\n\t\t\t\treturn reorderedValues;\n\t\t\t} else {\n\t\t\t\tint last = columnReorderingEnabledSetting ? column : column < headers.length ? headers.length : column;\n\n\t\t\t\tString[] out = new String[last];\n\t\t\t\tSystem.arraycopy(parsedValues, 0, out, 0, column);\n\t\t\t\tcolumn = 0;\n\t\t\t\tthis.appender = appenders[0];\n\t\t\t\treturn out;\n\t\t\t}\n\t\t} else if (!skipEmptyLines) { //no values were parsed, but we are not skipping empty lines\n\t\t\tif (!columnsToExtractInitialized) {\n\t\t\t\tinitializeHeaders();\n\t\t\t}\n\n\t\t\tcurrentRecord++;\n\n\t\t\tif (columnsReordered) {\n\t\t\t\tif(selectedIndexes.length == 0){\n\t\t\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t\t\t}\n\t\t\t\tString[] out = new String[selectedIndexes.length];\n\t\t\t\tArrays.fill(out, nullValue);\n\t\t\t\treturn out;\n\t\t\t}\n\n\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t}\n\t\t// no values were parsed and we do not care about empty lines.\n\t\treturn null;\n\t}\n",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 154,
        "method_end_line": 226
    },
    "31_src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java": {
        "context": "\tprivate char pickDelimiter(Map<Character, Integer> sums, Map<Character, Integer> totals) {\n\t\tchar delimiterMax = max(sums, totals, suggestedDelimiter);\n\t\tchar delimiterMin = min(sums, totals, suggestedDelimiter);\n\n\t\tchar delimiter;\n\t\tout:\n\t\tif (delimiterMax != delimiterMin) {\n\t\t\tif (sums.get(delimiterMin) == 0 && sums.get(delimiterMax) != 0) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\n\t\t\tfor (char c : delimiterPreference) {\n\t\t\t\tif (c == delimiterMin) {\n\t\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\t\tbreak out;\n\t\t\t\t} else if (c == delimiterMax) {\n\t\t\t\t\tdelimiter = delimiterMax;\n\t\t\t\t\tbreak out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (totals.get(delimiterMin) > totals.get(delimiterMax)) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\t\t\tdelimiter = delimiterMax;\n\t\t} else {\n\t\t\tdelimiter = delimiterMax;\n\t\t}\n\t\treturn delimiter;\n\t}\n",
        "start_line": 272,
        "end_line": 272,
        "bug_id": "31",
        "before": "\tprivate char pickDelimiter(Map<Character, Integer> sums, Map<Character, Integer> totals) {\n\t\tchar delimiterMax = max(sums, totals, suggestedDelimiter);\n\t\tchar delimiterMin = min(sums, totals, suggestedDelimiter);\n\n",
        "after": "\t\tchar delimiter;\n\t\tout:\n\t\tif (delimiterMax != delimiterMin) {\n\t\t\tif (sums.get(delimiterMin) == 0 && sums.get(delimiterMax) != 0) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\n\t\t\tfor (char c : delimiterPreference) {\n\t\t\t\tif (c == delimiterMin) {\n\t\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\t\tbreak out;\n\t\t\t\t} else if (c == delimiterMax) {\n\t\t\t\t\tdelimiter = delimiterMax;\n\t\t\t\t\tbreak out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (totals.get(delimiterMin) > totals.get(delimiterMax)) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\t\t\tdelimiter = delimiterMax;\n\t\t} else {\n\t\t\tdelimiter = delimiterMax;\n\t\t}\n\t\treturn delimiter;\n\t}\n",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 268,
        "method_end_line": 300
    },
    "33_src/main/java/com/univocity/parsers/csv/CsvParser.java": {
        "context": "\tprivate final void parseSingleDelimiterRecord() {\n\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t}\n\n\t\twhile (ch != newLine) {\n\t\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t\t}\n\n\t\t\tif (ch == delimiter || ch == newLine) {\n\t\t\t\toutput.emptyParsed();\n\t\t\t} else {\n\t\t\t\tunescaped = false;\n\t\t\t\tprev = '\\0';\n\t\t\t\tif (ch == quote) {\n\t\t\t\t\tinput.enableNormalizeLineEndings(normalizeLineEndingsInQuotes);\n\t\t\t\t\tint len = output.appender.length();\n\t\t\t\t\tif (len == 0) {\n\t\t\t\t\t\tString value = input.getQuotedString(quote, quoteEscape, escapeEscape, maxColumnLength, delimiter, newLine, keepQuotes, keepEscape, trimQuotedLeading, trimQuotedTrailing);\n\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\toutput.valueParsed(value == \"\" ? emptyValue : value);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\tif (ch == delimiter) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\t\t\tif (ch == newLine) {\n\t\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (len == -1 && input.skipQuotedString(quote, quoteEscape, delimiter, newLine)) {\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\tif (ch == delimiter) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\t\tif (ch == newLine) {\n\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\toutput.trim = trimQuotedTrailing;\n\t\t\t\t\tparseQuotedValue();\n\t\t\t\t\tinput.enableNormalizeLineEndings(true);\n\t\t\t\t\tif (!(unescaped && quoteHandling == BACK_TO_DELIMITER && output.appender.length() == 0)) {\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t}\n\t\t\t\t} else if (doNotEscapeUnquotedValues) {\n\t\t\t\t\tString value = null;\n\t\t\t\t\tint len = output.appender.length();\n\t\t\t\t\tif (len == 0) {\n\t\t\t\t\t\tvalue = input.getString(ch, delimiter, ignoreTrailingWhitespace, nullValue, maxColumnLength);\n\t\t\t\t\t}\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\toutput.valueParsed(value);\n\t\t\t\t\t\tch = input.getChar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (len != -1) {\n\t\t\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (input.skipString(ch, delimiter)) {\n\t\t\t\t\t\t\t\tch = input.getChar();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\tparseValueProcessingEscape();\n\t\t\t\t\toutput.valueParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ch != newLine) {\n\t\t\t\tch = input.nextChar();\n\t\t\t\tif (ch == newLine) {\n\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
        "start_line": 140,
        "end_line": 140,
        "bug_id": "33",
        "before": "\tprivate final void parseSingleDelimiterRecord() {\n\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t}\n\n\t\twhile (ch != newLine) {\n\t\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t\t}\n\n\t\t\tif (ch == delimiter || ch == newLine) {\n\t\t\t\toutput.emptyParsed();\n\t\t\t} else {\n\t\t\t\tunescaped = false;\n\t\t\t\tprev = '\\0';\n\t\t\t\tif (ch == quote) {\n\t\t\t\t\tinput.enableNormalizeLineEndings(normalizeLineEndingsInQuotes);\n\t\t\t\t\tint len = output.appender.length();\n\t\t\t\t\tif (len == 0) {\n\t\t\t\t\t\tString value = input.getQuotedString(quote, quoteEscape, escapeEscape, maxColumnLength, delimiter, newLine, keepQuotes, keepEscape, trimQuotedLeading, trimQuotedTrailing);\n\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\toutput.valueParsed(value == \"\" ? emptyValue : value);\n",
        "after": "\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\tif (ch == delimiter) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\t\t\tif (ch == newLine) {\n\t\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (len == -1 && input.skipQuotedString(quote, quoteEscape, delimiter, newLine)) {\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\tif (ch == delimiter) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\t\tif (ch == newLine) {\n\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\toutput.trim = trimQuotedTrailing;\n\t\t\t\t\tparseQuotedValue();\n\t\t\t\t\tinput.enableNormalizeLineEndings(true);\n\t\t\t\t\tif (!(unescaped && quoteHandling == BACK_TO_DELIMITER && output.appender.length() == 0)) {\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t}\n\t\t\t\t} else if (doNotEscapeUnquotedValues) {\n\t\t\t\t\tString value = null;\n\t\t\t\t\tint len = output.appender.length();\n\t\t\t\t\tif (len == 0) {\n\t\t\t\t\t\tvalue = input.getString(ch, delimiter, ignoreTrailingWhitespace, nullValue, maxColumnLength);\n\t\t\t\t\t}\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\toutput.valueParsed(value);\n\t\t\t\t\t\tch = input.getChar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (len != -1) {\n\t\t\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (input.skipString(ch, delimiter)) {\n\t\t\t\t\t\t\t\tch = input.getChar();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\tparseValueProcessingEscape();\n\t\t\t\t\toutput.valueParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ch != newLine) {\n\t\t\t\tch = input.nextChar();\n\t\t\t\tif (ch == newLine) {\n\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 118,
        "method_end_line": 220
    },
    "34_src/main/java/com/univocity/parsers/common/AbstractWriter.java": {
        "context": "\tprivate <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n\t\ttry {\n\t\t\tIterator[] iterators = new Iterator[rowData.size()];\n\t\t\tObject[] keys = new Object[rowData.size()];\n\t\t\tfinal Map<Object, Object> rowValues = new LinkedHashMap<Object, Object>(rowData.size());\n\n\t\t\tif(headers == null){\n\t\t\t\tif(headerMapping != null){\n\t\t\t\t\tsetHeadersFromMap(headerMapping, true);\n\t\t\t\t} else {\n\t\t\t\t\tsetHeadersFromMap(rowData, true);\n\t\t\t\t}\n\t\t\t\tif(isHeaderWritingEnabled && recordCount == 0){\n\t\t\t\t\toutputList.add(writeHeadersToString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint length = 0;\n\t\t\tfor (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n\t\t\t\titerators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n\t\t\t\tkeys[length] = rowEntry.getKey();\n\t\t\t\trowValues.put(rowEntry.getKey(), null);\n\t\t\t\tlength++;\n\t\t\t}\n\t\t\tboolean nullsOnly;\n\n\t\t\tdo {\n\t\t\t\tnullsOnly = true;\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tIterator<?> iterator = iterators[i];\n\t\t\t\t\tboolean isNull = iterator == null || !iterator.hasNext();\n\t\t\t\t\tnullsOnly &= isNull;\n\t\t\t\t\tif (isNull) {\n\t\t\t\t\t\trowValues.put(keys[i], null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trowValues.put(keys[i], iterator.next());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!nullsOnly) {\n\t\t\t\t\tif (outputList == null) {\n\t\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\t\tprocessRecord((Map) headerMapping, (Map) rowValues);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteRow((Map) headerMapping, (Map) rowValues);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\t\toutputList.add(processRecordToString((Map) headerMapping, (Map) rowValues));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toutputList.add(writeRowToString((Map) headerMapping, (Map) rowValues));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!nullsOnly);\n\t\t} catch (Throwable t) {\n\t\t\tthrow throwExceptionAndClose(\"Error processing input rows from map\", t);\n\t\t}\n\t}\n",
        "start_line": 1738,
        "end_line": 1739,
        "bug_id": "34",
        "before": "\tprivate <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n\t\ttry {\n\t\t\tIterator[] iterators = new Iterator[rowData.size()];\n\t\t\tObject[] keys = new Object[rowData.size()];\n\t\t\tfinal Map<Object, Object> rowValues = new LinkedHashMap<Object, Object>(rowData.size());\n\n",
        "after": "\t\t\t\tif(headerMapping != null){\n\t\t\t\t\tsetHeadersFromMap(headerMapping, true);\n\t\t\t\t} else {\n\t\t\t\t\tsetHeadersFromMap(rowData, true);\n\t\t\t\t}\n\t\t\t\tif(isHeaderWritingEnabled && recordCount == 0){\n\t\t\t\t\toutputList.add(writeHeadersToString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint length = 0;\n\t\t\tfor (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n\t\t\t\titerators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n\t\t\t\tkeys[length] = rowEntry.getKey();\n\t\t\t\trowValues.put(rowEntry.getKey(), null);\n\t\t\t\tlength++;\n\t\t\t}\n\t\t\tboolean nullsOnly;\n\n\t\t\tdo {\n\t\t\t\tnullsOnly = true;\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tIterator<?> iterator = iterators[i];\n\t\t\t\t\tboolean isNull = iterator == null || !iterator.hasNext();\n\t\t\t\t\tnullsOnly &= isNull;\n\t\t\t\t\tif (isNull) {\n\t\t\t\t\t\trowValues.put(keys[i], null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trowValues.put(keys[i], iterator.next());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!nullsOnly) {\n\t\t\t\t\tif (outputList == null) {\n\t\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\t\tprocessRecord((Map) headerMapping, (Map) rowValues);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteRow((Map) headerMapping, (Map) rowValues);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\t\toutputList.add(processRecordToString((Map) headerMapping, (Map) rowValues));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toutputList.add(writeRowToString((Map) headerMapping, (Map) rowValues));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!nullsOnly);\n\t\t} catch (Throwable t) {\n\t\t\tthrow throwExceptionAndClose(\"Error processing input rows from map\", t);\n\t\t}\n\t}\n",
        "buggy_line": "if(headers == null){",
        "buggy_lines": "\t\t\tif(headers == null){\n",
        "method_start_line": 1732,
        "method_end_line": 1790
    },
    "35_src/main/java/com/univocity/parsers/csv/CsvParser.java": {
        "context": "\t@Override\n\tprotected final void parseRecord() {\n\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t}\n\n\t\twhile (ch != newLine) {\n\t\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t\t}\n\n\t\t\tif (ch == delimiter || ch == newLine) {\n\t\t\t\toutput.emptyParsed();\n\t\t\t} else {\n\t\t\t\tunescaped = false;\n\t\t\t\tprev = '\\0';\n\t\t\t\tif (ch == quote) {\n\t\t\t\t\toutput.trim = false;\n\t\t\t\t\tinput.enableNormalizeLineEndings(normalizeLineEndingsInQuotes);\n\t\t\t\t\tif (output.appender.length() == 0) {\n\t\t\t\t\t\tString value = input.getQuotedString(quote, quoteEscape, escapeEscape, maxColumnLength, delimiter, newLine, keepQuotes, keepEscape);\n\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\toutput.valueParsed(value == \"\" ? emptyValue : value);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\tif (ch == delimiter) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparseQuotedValue();\n\t\t\t\t\tinput.enableNormalizeLineEndings(true);\n\t\t\t\t\toutput.valueParsed();\n\t\t\t\t} else if (doNotEscapeUnquotedValues) {\n\t\t\t\t\tString value = null;\n\t\t\t\t\tif (output.appender.length() == 0) {\n\t\t\t\t\t\tvalue = input.getString(ch, delimiter, ignoreTrailingWhitespace, nullValue, maxColumnLength);\n\t\t\t\t\t}\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\toutput.valueParsed(value);\n\t\t\t\t\t\tch = input.getChar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\tparseValueProcessingEscape();\n\t\t\t\t\toutput.valueParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ch != newLine) {\n\t\t\t\tch = input.nextChar();\n\t\t\t\tif (ch == newLine) {\n\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n",
        "start_line": 128,
        "end_line": 128,
        "bug_id": "35",
        "before": "\t@Override\n\tprotected final void parseRecord() {\n\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t}\n\n\t\twhile (ch != newLine) {\n\t\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t\t}\n\n\t\t\tif (ch == delimiter || ch == newLine) {\n\t\t\t\toutput.emptyParsed();\n\t\t\t} else {\n\t\t\t\tunescaped = false;\n\t\t\t\tprev = '\\0';\n\t\t\t\tif (ch == quote) {\n\t\t\t\t\toutput.trim = false;\n\t\t\t\t\tinput.enableNormalizeLineEndings(normalizeLineEndingsInQuotes);\n\t\t\t\t\tif (output.appender.length() == 0) {\n\t\t\t\t\t\tString value = input.getQuotedString(quote, quoteEscape, escapeEscape, maxColumnLength, delimiter, newLine, keepQuotes, keepEscape);\n\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\toutput.valueParsed(value == \"\" ? emptyValue : value);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\tif (ch == delimiter) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tch = input.nextChar();\n",
        "after": "\t\t\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparseQuotedValue();\n\t\t\t\t\tinput.enableNormalizeLineEndings(true);\n\t\t\t\t\toutput.valueParsed();\n\t\t\t\t} else if (doNotEscapeUnquotedValues) {\n\t\t\t\t\tString value = null;\n\t\t\t\t\tif (output.appender.length() == 0) {\n\t\t\t\t\t\tvalue = input.getString(ch, delimiter, ignoreTrailingWhitespace, nullValue, maxColumnLength);\n\t\t\t\t\t}\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\toutput.valueParsed(value);\n\t\t\t\t\t\tch = input.getChar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\tparseValueProcessingEscape();\n\t\t\t\t\toutput.valueParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ch != newLine) {\n\t\t\t\tch = input.nextChar();\n\t\t\t\tif (ch == newLine) {\n\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 100,
        "method_end_line": 170
    },
    "36_src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java": {
        "context": "\t@Override\n\tpublic void execute(char[] characters, int length) {\n\n\t\tSet<Character> allSymbols = new HashSet<Character>();\n\t\tMap<Character, Integer> symbols = new HashMap<Character, Integer>();\n\t\tMap<Character, Integer> escape = new HashMap<Character, Integer>();\n\t\tList<Map<Character, Integer>> symbolsPerRow = new ArrayList<Map<Character, Integer>>();\n\n\t\tint doubleQuoteCount = 0;\n\t\tint singleQuoteCount = 0;\n\n\t\tint i;\n\t\tchar inQuote = '\\0';\n\t\tboolean afterNewLine = true;\n\t\tfor (i = 0; i < length; i++) {\n\n\t\t\tchar ch = characters[i];\n\n\t\t\tif (afterNewLine && ch == comment) {\n\t\t\t\twhile (++i < length) {\n\t\t\t\t\tch = characters[i];\n\t\t\t\t\tif (ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ch == '\"' || ch == '\\'') {\n\t\t\t\tif (inQuote == ch) { //closing quotes (potentially)\n\t\t\t\t\tif (ch == '\"') {\n\t\t\t\t\t\tdoubleQuoteCount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsingleQuoteCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i + 1 < length) {\n\t\t\t\t\t\tchar next = characters[i + 1];\n\t\t\t\t\t\tif (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\\n' && next != '\\r')) { //no special characters after quote, might be escaping\n\t\t\t\t\t\t\t//special character before (potentially) closing quote, might be an escape\n\t\t\t\t\t\t\tchar prev = characters[i - 1];\n\t\t\t\t\t\t\tif (!Character.isLetterOrDigit(prev)) {\n\t\t\t\t\t\t\t\tincrement(escape, prev);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tinQuote = '\\0';\n\t\t\t\t} else if (inQuote == '\\0') {\n\t\t\t\t\tchar prev = '\\0';\n\t\t\t\t\tint j = i;\n\t\t\t\t\twhile (prev <= ' ' && --j >= 0) {\n\t\t\t\t\t\tprev = characters[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j < 0 || !Character.isLetterOrDigit(prev)) {\n\t\t\t\t\t\tinQuote = ch;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inQuote != '\\0') { //keep looping until the quote is closed.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tafterNewLine = false;\n\n\t\t\tif (isSymbol(ch)) { //counts all symbols. Skips letters, digits and white spaces (except the tab character)\n\t\t\t\tallSymbols.add(ch);\n\t\t\t\tincrement(symbols, ch);\n\t\t\t} else if ((ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) && symbols.size() > 0) { //got a newline and collected some symbols? Good!\n\t\t\t\tafterNewLine = true;\n\t\t\t\tsymbolsPerRow.add(symbols);\n\t\t\t\tif (symbolsPerRow.size() == MAX_ROW_SAMPLES) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsymbols = new HashMap<Character, Integer>();\n\t\t\t}\n\t\t}\n\n\t\tif (i >= length && symbolsPerRow.size() > 1) { // if got to the end of the buffer, discard last row. It's probably incomplete anyway.\n\t\t\tsymbolsPerRow.remove(symbolsPerRow.size() - 1);\n\t\t}\n\n\t\tMap<Character, Integer> totals = calculateTotals(symbolsPerRow);\n\n\t\tMap<Character, Integer> sums = new HashMap<Character, Integer>();\n\t\tSet<Character> toRemove = new HashSet<Character>();\n\n\t\t//combines the number of symbols found in each row and sums the difference.\n\t\tfor (Map<Character, Integer> previous : symbolsPerRow) {\n\t\t\tfor (Map<Character, Integer> current : symbolsPerRow) {\n\t\t\t\tfor (Character symbol : allSymbols) {\n\t\t\t\t\tInteger previousCount = previous.get(symbol);\n\t\t\t\t\tInteger currentCount = current.get(symbol);\n\n\t\t\t\t\tif (previousCount == null && currentCount == null) { // got a symbol that does not appear in all rows? Discard it.\n\t\t\t\t\t\ttoRemove.add(symbol);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (previousCount == null || currentCount == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tincrement(sums, symbol, Math.abs(previousCount - currentCount)); // we expect to always get 0 or close to 0 here, so the symbol occurs in all rows\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsums.keySet().removeAll(toRemove);\n\n\t\tchar delimiter = max(sums, totals, suggestedDelimiter);\n\t\tchar quote = doubleQuoteCount >= singleQuoteCount ? '\"' : '\\'';\n\n\t\tescape.remove(delimiter);\n\t\tchar quoteEscape = max(escape, totals, quote);\n\t\tapply(delimiter, quote, quoteEscape);\n\t}\n",
        "start_line": 181,
        "end_line": 182,
        "bug_id": "36",
        "before": "\t@Override\n\tpublic void execute(char[] characters, int length) {\n\n\t\tSet<Character> allSymbols = new HashSet<Character>();\n\t\tMap<Character, Integer> symbols = new HashMap<Character, Integer>();\n\t\tMap<Character, Integer> escape = new HashMap<Character, Integer>();\n\t\tList<Map<Character, Integer>> symbolsPerRow = new ArrayList<Map<Character, Integer>>();\n\n\t\tint doubleQuoteCount = 0;\n\t\tint singleQuoteCount = 0;\n\n\t\tint i;\n\t\tchar inQuote = '\\0';\n\t\tboolean afterNewLine = true;\n\t\tfor (i = 0; i < length; i++) {\n\n\t\t\tchar ch = characters[i];\n\n\t\t\tif (afterNewLine && ch == comment) {\n\t\t\t\twhile (++i < length) {\n\t\t\t\t\tch = characters[i];\n\t\t\t\t\tif (ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ch == '\"' || ch == '\\'') {\n\t\t\t\tif (inQuote == ch) { //closing quotes (potentially)\n\t\t\t\t\tif (ch == '\"') {\n\t\t\t\t\t\tdoubleQuoteCount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsingleQuoteCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i + 1 < length) {\n\t\t\t\t\t\tchar next = characters[i + 1];\n\t\t\t\t\t\tif (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\\n' && next != '\\r')) { //no special characters after quote, might be escaping\n\t\t\t\t\t\t\t//special character before (potentially) closing quote, might be an escape\n\t\t\t\t\t\t\tchar prev = characters[i - 1];\n\t\t\t\t\t\t\tif (!Character.isLetterOrDigit(prev)) {\n\t\t\t\t\t\t\t\tincrement(escape, prev);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tinQuote = '\\0';\n\t\t\t\t} else if (inQuote == '\\0') {\n\t\t\t\t\tchar prev = '\\0';\n\t\t\t\t\tint j = i;\n\t\t\t\t\twhile (prev <= ' ' && --j >= 0) {\n\t\t\t\t\t\tprev = characters[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j < 0 || !Character.isLetterOrDigit(prev)) {\n\t\t\t\t\t\tinQuote = ch;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inQuote != '\\0') { //keep looping until the quote is closed.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tafterNewLine = false;\n\n\t\t\tif (isSymbol(ch)) { //counts all symbols. Skips letters, digits and white spaces (except the tab character)\n\t\t\t\tallSymbols.add(ch);\n\t\t\t\tincrement(symbols, ch);\n\t\t\t} else if ((ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) && symbols.size() > 0) { //got a newline and collected some symbols? Good!\n\t\t\t\tafterNewLine = true;\n\t\t\t\tsymbolsPerRow.add(symbols);\n\t\t\t\tif (symbolsPerRow.size() == MAX_ROW_SAMPLES) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsymbols = new HashMap<Character, Integer>();\n\t\t\t}\n\t\t}\n\n\t\tif (i >= length && symbolsPerRow.size() > 1) { // if got to the end of the buffer, discard last row. It's probably incomplete anyway.\n\t\t\tsymbolsPerRow.remove(symbolsPerRow.size() - 1);\n\t\t}\n\n\t\tMap<Character, Integer> totals = calculateTotals(symbolsPerRow);\n\n\t\tMap<Character, Integer> sums = new HashMap<Character, Integer>();\n\t\tSet<Character> toRemove = new HashSet<Character>();\n\n\t\t//combines the number of symbols found in each row and sums the difference.\n\t\tfor (Map<Character, Integer> previous : symbolsPerRow) {\n\t\t\tfor (Map<Character, Integer> current : symbolsPerRow) {\n\t\t\t\tfor (Character symbol : allSymbols) {\n\t\t\t\t\tInteger previousCount = previous.get(symbol);\n\t\t\t\t\tInteger currentCount = current.get(symbol);\n\n\t\t\t\t\tif (previousCount == null && currentCount == null) { // got a symbol that does not appear in all rows? Discard it.\n\t\t\t\t\t\ttoRemove.add(symbol);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (previousCount == null || currentCount == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tincrement(sums, symbol, Math.abs(previousCount - currentCount)); // we expect to always get 0 or close to 0 here, so the symbol occurs in all rows\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsums.keySet().removeAll(toRemove);\n\n",
        "after": "\t\tchar quote = doubleQuoteCount >= singleQuoteCount ? '\"' : '\\'';\n\n\t\tescape.remove(delimiter);\n\t\tchar quoteEscape = max(escape, totals, quote);\n\t\tapply(delimiter, quote, quoteEscape);\n\t}\n",
        "buggy_line": "char delimiter = max(sums, totals, suggestedDelimiter);",
        "buggy_lines": "\t\tchar delimiter = max(sums, totals, suggestedDelimiter);\n",
        "method_start_line": 70,
        "method_end_line": 188
    },
    "37_src/main/java/com/univocity/parsers/common/processor/core/BeanConversionProcessor.java": {
        "context": "\tvoid mapValuesToFields(T instance, Object[] row, Context context) {\n\t\tif (row.length > lastFieldIndexMapped) {\n\t\t\tthis.lastFieldIndexMapped = row.length;\n\t\t\tmapFieldIndexes(context, row, context.headers(), context.extractedFieldIndexes(), context.columnsReordered());\n\t\t}\n\n\t\tint last = row.length < readOrder.length ? row.length : readOrder.length;\n\t\tint i = 0;\n\t\tfor (; i < last; i++) {\n\t\t\tFieldMapping field = readOrder[i];\n\t\t\tif (field != null) {\n\t\t\t\tObject value = row[i];\n\t\t\t\tfield.write(instance, value);\n\t\t\t}\n\t\t}\n\n\t\tif (row.length < readOrder.length) {\n\t\t\ti = last;\n\t\t\tfor (; i < readOrder.length; i++) {\n\t\t\t\tFieldMapping field = readOrder[i];\n\t\t\t\tif (field != null) {\n\t\t\t\t\tObject value = conversions.applyConversions(i, null, null);\n\t\t\t\t\tfield.write(instance, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (missing != null) {\n\t\t\tfor (i = 0; i < missing.length; i++) {\n\t\t\t\tObject value = valuesForMissing[i];\n\t\t\t\tif (value != null) {\n\t\t\t\t\tFieldMapping field = missing[i];\n\t\t\t\t\tfield.write(instance, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n",
        "start_line": 365,
        "end_line": 366,
        "bug_id": "37",
        "before": "\tvoid mapValuesToFields(T instance, Object[] row, Context context) {\n\t\tif (row.length > lastFieldIndexMapped) {\n\t\t\tthis.lastFieldIndexMapped = row.length;\n\t\t\tmapFieldIndexes(context, row, context.headers(), context.extractedFieldIndexes(), context.columnsReordered());\n\t\t}\n\n\t\tint last = row.length < readOrder.length ? row.length : readOrder.length;\n\t\tint i = 0;\n\t\tfor (; i < last; i++) {\n\t\t\tFieldMapping field = readOrder[i];\n\t\t\tif (field != null) {\n\t\t\t\tObject value = row[i];\n\t\t\t\tfield.write(instance, value);\n\t\t\t}\n\t\t}\n\n",
        "after": "\t\t\ti = last;\n\t\t\tfor (; i < readOrder.length; i++) {\n\t\t\t\tFieldMapping field = readOrder[i];\n\t\t\t\tif (field != null) {\n\t\t\t\t\tObject value = conversions.applyConversions(i, null, null);\n\t\t\t\t\tfield.write(instance, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (missing != null) {\n\t\t\tfor (i = 0; i < missing.length; i++) {\n\t\t\t\tObject value = valuesForMissing[i];\n\t\t\t\tif (value != null) {\n\t\t\t\t\tFieldMapping field = missing[i];\n\t\t\t\t\tfield.write(instance, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n",
        "buggy_line": "if (row.length < readOrder.length) {",
        "buggy_lines": "\t\tif (row.length < readOrder.length) {\n",
        "method_start_line": 349,
        "method_end_line": 387
    },
    "38_src/main/java/com/univocity/parsers/common/input/AbstractCharInputReader.java": {
        "context": "\tprivate void updateBuffer() {\n\t\tif (length - recordStart > 0 && buffer != null) {\n\t\t\ttmp.append(buffer, recordStart, length - recordStart);\n\t\t}\n\t\trecordStart = 0;\n\t\treloadBuffer();\n\n\t\tcharCount += i;\n\t\ti = 0;\n\n\t\tif (length == -1) {\n\t\t\tstop();\n\t\t\tincrementLineCount = true;\n\t\t}\n\n\t\tif (inputAnalysisProcesses != null) {\n\t\t\ttry {\n\t\t\t\tfor (InputAnalysisProcess process : inputAnalysisProcesses) {\n\t\t\t\t\tprocess.execute(buffer, length);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tinputAnalysisProcesses = null;\n\t\t\t}\n\t\t}\n\t}\n",
        "start_line": 205,
        "end_line": 206,
        "bug_id": "38",
        "before": "\tprivate void updateBuffer() {\n\t\tif (length - recordStart > 0 && buffer != null) {\n\t\t\ttmp.append(buffer, recordStart, length - recordStart);\n\t\t}\n\t\trecordStart = 0;\n\t\treloadBuffer();\n\n\t\tcharCount += i;\n\t\ti = 0;\n\n\t\tif (length == -1) {\n\t\t\tstop();\n\t\t\tincrementLineCount = true;\n\t\t}\n\n\t\tif (inputAnalysisProcesses != null) {\n\t\t\ttry {\n\t\t\t\tfor (InputAnalysisProcess process : inputAnalysisProcesses) {\n\t\t\t\t\tprocess.execute(buffer, length);\n\t\t\t\t}\n\t\t\t} finally {\n",
        "after": "\t\t\t}\n\t\t}\n\t}\n",
        "buggy_line": "inputAnalysisProcesses = null;",
        "buggy_lines": "\t\t\t\tinputAnalysisProcesses = null;\n",
        "method_start_line": 184,
        "method_end_line": 209
    },
    "39_src/main/java/com/univocity/parsers/csv/CsvParser.java": {
        "context": "\tprivate void parseQuotedValue() {\n\t\tif (prev != '\\0' && parseUnescapedQuotesUntilDelimiter) {\n\t\t\tif (quoteHandling == SKIP_VALUE) {\n\t\t\t\tskipValue();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!keepQuotes) {\n\t\t\t\toutput.appender.prepend(quote);\n\t\t\t}\n\t\t\tch = input.nextChar();\n\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t} else {\n\t\t\tif (keepQuotes && prev == '\\0') {\n\t\t\t\toutput.appender.append(quote);\n\t\t\t}\n\t\t\tch = input.nextChar();\n\t\t\twhile (true) {\n\t\t\t\tif (prev == quote && (ch <= ' ' && whitespaceRangeStart < ch || ch == delimiter || ch == newLine)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ch != quote && ch != quoteEscape) {\n\t\t\t\t\tif (prev == quote) { //unescaped quote detected\n\t\t\t\t\t\tif (handleUnescapedQuote()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (prev == quoteEscape && quoteEscape != '\\0') {\n\t\t\t\t\t\toutput.appender.append(quoteEscape);\n\t\t\t\t\t}\n\t\t\t\t\tch = output.appender.appendUntil(ch, input, quote, quoteEscape, escapeEscape);\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tch = input.nextChar();\n\t\t\t\t} else {\n\t\t\t\t\tprocessQuoteEscape();\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\tif(unescaped && ch == delimiter || ch == newLine){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// handles whitespaces after quoted value: whitespaces are ignored. Content after whitespaces may be parsed if 'parseUnescapedQuotes' is enabled.\n\t\t\tif (ch != delimiter && ch != newLine && ch <= ' ' && whitespaceRangeStart < ch) {\n\t\t\t\twhitespaceAppender.reset();\n\t\t\t\tdo {\n\t\t\t\t\t//saves whitespaces after value\n\t\t\t\t\twhitespaceAppender.append(ch);\n\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t//found a new line, go to next record.\n\t\t\t\t\tif (ch == newLine) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} while (ch <= ' ' && whitespaceRangeStart < ch);\n\n\t\t\t\t//there's more stuff after the quoted value, not only empty spaces.\n\t\t\t\tif (ch != delimiter && parseUnescapedQuotes) {\n\t\t\t\t\tif (output.appender instanceof DefaultCharAppender) {\n\t\t\t\t\t\t//puts the quote before whitespaces back, then restores the whitespaces\n\t\t\t\t\t\toutput.appender.append(quote);\n\t\t\t\t\t\t((DefaultCharAppender) output.appender).append(whitespaceAppender);\n\t\t\t\t\t}\n\t\t\t\t\t//the next character is not the escape character, put it there\n\t\t\t\t\tif (parseUnescapedQuotesUntilDelimiter || ch != quote && ch != quoteEscape) {\n\t\t\t\t\t\toutput.appender.append(ch);\n\t\t\t\t\t}\n\n\t\t\t\t\t//sets this character as the previous character (may be escaping)\n\t\t\t\t\t//calls recursively to keep parsing potentially quoted content\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tparseQuotedValue();\n\t\t\t\t} else if (keepQuotes) {\n\t\t\t\t\toutput.appender.append(quote);\n\t\t\t\t}\n\t\t\t} else if (keepQuotes) {\n\t\t\t\toutput.appender.append(quote);\n\t\t\t}\n\n\t\t\tif (ch != delimiter && ch != newLine) {\n\t\t\t\tthrow new TextParsingException(context, \"Unexpected character '\" + ch + \"' following quoted value of CSV field. Expecting '\" + delimiter + \"'. Cannot parse CSV input.\");\n\t\t\t}\n\t\t}\n\t}\n",
        "start_line": 283,
        "end_line": 284,
        "bug_id": "39",
        "before": "\tprivate void parseQuotedValue() {\n\t\tif (prev != '\\0' && parseUnescapedQuotesUntilDelimiter) {\n\t\t\tif (quoteHandling == SKIP_VALUE) {\n\t\t\t\tskipValue();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!keepQuotes) {\n\t\t\t\toutput.appender.prepend(quote);\n\t\t\t}\n\t\t\tch = input.nextChar();\n\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t} else {\n\t\t\tif (keepQuotes && prev == '\\0') {\n\t\t\t\toutput.appender.append(quote);\n\t\t\t}\n\t\t\tch = input.nextChar();\n\t\t\twhile (true) {\n\t\t\t\tif (prev == quote && (ch <= ' ' && whitespaceRangeStart < ch || ch == delimiter || ch == newLine)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ch != quote && ch != quoteEscape) {\n\t\t\t\t\tif (prev == quote) { //unescaped quote detected\n\t\t\t\t\t\tif (handleUnescapedQuote()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (prev == quoteEscape && quoteEscape != '\\0') {\n\t\t\t\t\t\toutput.appender.append(quoteEscape);\n\t\t\t\t\t}\n\t\t\t\t\tch = output.appender.appendUntil(ch, input, quote, quoteEscape, escapeEscape);\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tch = input.nextChar();\n\t\t\t\t} else {\n\t\t\t\t\tprocessQuoteEscape();\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tch = input.nextChar();\n",
        "after": "\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// handles whitespaces after quoted value: whitespaces are ignored. Content after whitespaces may be parsed if 'parseUnescapedQuotes' is enabled.\n\t\t\tif (ch != delimiter && ch != newLine && ch <= ' ' && whitespaceRangeStart < ch) {\n\t\t\t\twhitespaceAppender.reset();\n\t\t\t\tdo {\n\t\t\t\t\t//saves whitespaces after value\n\t\t\t\t\twhitespaceAppender.append(ch);\n\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t//found a new line, go to next record.\n\t\t\t\t\tif (ch == newLine) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} while (ch <= ' ' && whitespaceRangeStart < ch);\n\n\t\t\t\t//there's more stuff after the quoted value, not only empty spaces.\n\t\t\t\tif (ch != delimiter && parseUnescapedQuotes) {\n\t\t\t\t\tif (output.appender instanceof DefaultCharAppender) {\n\t\t\t\t\t\t//puts the quote before whitespaces back, then restores the whitespaces\n\t\t\t\t\t\toutput.appender.append(quote);\n\t\t\t\t\t\t((DefaultCharAppender) output.appender).append(whitespaceAppender);\n\t\t\t\t\t}\n\t\t\t\t\t//the next character is not the escape character, put it there\n\t\t\t\t\tif (parseUnescapedQuotesUntilDelimiter || ch != quote && ch != quoteEscape) {\n\t\t\t\t\t\toutput.appender.append(ch);\n\t\t\t\t\t}\n\n\t\t\t\t\t//sets this character as the previous character (may be escaping)\n\t\t\t\t\t//calls recursively to keep parsing potentially quoted content\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tparseQuotedValue();\n\t\t\t\t} else if (keepQuotes) {\n\t\t\t\t\toutput.appender.append(quote);\n\t\t\t\t}\n\t\t\t} else if (keepQuotes) {\n\t\t\t\toutput.appender.append(quote);\n\t\t\t}\n\n\t\t\tif (ch != delimiter && ch != newLine) {\n\t\t\t\tthrow new TextParsingException(context, \"Unexpected character '\" + ch + \"' following quoted value of CSV field. Expecting '\" + delimiter + \"'. Cannot parse CSV input.\");\n\t\t\t}\n\t\t}\n\t}\n",
        "buggy_line": "if(unescaped && ch == delimiter || ch == newLine){",
        "buggy_lines": "\t\t\t\t\tif(unescaped && ch == delimiter || ch == newLine){\n",
        "method_start_line": 243,
        "method_end_line": 330
    },
    "40_src/main/java/org/jsoup/parser/XmlTreeBuilder.java": {
        "context": "    private void popStackToClose(Token.EndTag endTag) {\n        String elName = endTag.normalName();\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n",
        "start_line": 117,
        "end_line": 118,
        "bug_id": "40",
        "before": "    private void popStackToClose(Token.EndTag endTag) {\n",
        "after": "        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n",
        "buggy_line": "String elName = endTag.normalName();",
        "buggy_lines": "        String elName = endTag.normalName();\n",
        "method_start_line": 116,
        "method_end_line": 137
    },
    "41_src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java": {
        "context": "        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = t.asEndTag().name(); // matches with case sensitivity if enabled\n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n",
        "start_line": 763,
        "end_line": 764,
        "bug_id": "41",
        "before": "        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n",
        "after": "            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n",
        "buggy_line": "String name = t.asEndTag().name(); // matches with case sensitivity if enabled",
        "buggy_lines": "            String name = t.asEndTag().name(); // matches with case sensitivity if enabled\n",
        "method_start_line": 762,
        "method_end_line": 782
    },
    "42_src/main/java/org/jsoup/internal/StringUtil.java": {
        "context": "    public static boolean isInvisibleChar(int c) {\n        return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);\n        // zero width sp, zw non join, zw join, soft hyphen\n    }\n",
        "start_line": 135,
        "end_line": 137,
        "bug_id": "42",
        "before": "    public static boolean isInvisibleChar(int c) {\n",
        "after": "    }\n",
        "buggy_line": "return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);        // zero width sp, zw non join, zw join, soft hyphen",
        "buggy_lines": "        return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);\n        // zero width sp, zw non join, zw join, soft hyphen\n",
        "method_start_line": 134,
        "method_end_line": 138
    },
    "43_src/main/java/org/jsoup/nodes/Attribute.java": {
        "context": "    public String getValue() {\n        return val;\n    }\n",
        "start_line": 80,
        "end_line": 81,
        "bug_id": "43",
        "before": "    public String getValue() {\n",
        "after": "    }\n",
        "buggy_line": "return val;",
        "buggy_lines": "        return val;\n",
        "method_start_line": 79,
        "method_end_line": 82
    },
    "44_src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java": {
        "context": "    public final float scanFieldFloat(char[] fieldName) {\n        matchStat = UNKNOWN;\n\n        if (!charArrayCompare(fieldName)) {\n            matchStat = NOT_MATCH_NAME;\n            return 0;\n        }\n\n        int offset = fieldName.length;\n        char chLocal = charAt(bp + (offset++));\n\n        final boolean quote = chLocal == '\"';\n        if (quote) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        boolean negative = chLocal == '-';\n        if (negative) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        float value;\n        if (chLocal >= '0' && chLocal <= '9') {\n            int intVal = chLocal - '0';\n            for (;;) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal >= '0' && chLocal <= '9') {\n                    intVal = intVal * 10 + (chLocal - '0');\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            int power = 1;\n            boolean small = (chLocal == '.');\n            if (small) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal >= '0' && chLocal <= '9') {\n                    intVal = intVal * 10 + (chLocal - '0');\n                    power = 10;\n                    for (;;) {\n                        chLocal = charAt(bp + (offset++));\n                        if (chLocal >= '0' && chLocal <= '9') {\n                            intVal = intVal * 10 + (chLocal - '0');\n                            power *= 10;\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                } else {\n                    matchStat = NOT_MATCH;\n                    return 0;\n                }\n            }\n\n            boolean exp = chLocal == 'e' || chLocal == 'E';\n            if (exp) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal == '+' || chLocal == '-') {\n                    chLocal = charAt(bp + (offset++));\n                }\n                for (;;) {\n                    if (chLocal >= '0' && chLocal <= '9') {\n                        chLocal = charAt(bp + (offset++));\n                    } else {\n                        break;\n                    }\n                }\n            }\n\n            int start, count;\n            if (quote) {\n                if (chLocal != '\"') {\n                    matchStat = NOT_MATCH;\n                    return 0;\n                } else {\n                    chLocal = charAt(bp + (offset++));\n                }\n                start = bp + fieldName.length + 1;\n                count = bp + offset - start - 2;\n            } else {\n                start = bp + fieldName.length;\n                count = bp + offset - start - 1;\n            }\n\n            if (!exp && count < 20) {\n                value = ((float) intVal) / power;\n                if (negative) {\n                    value = -value;\n                }\n            } else {\n                String text = this.subString(start, count);\n                value = Float.parseFloat(text);\n            }\n        } else if (chLocal == 'n' && charAt(bp + offset) == 'u' && charAt(bp + offset + 1) == 'l' && charAt(bp + offset + 2) == 'l') {\n            matchStat = VALUE_NULL;\n            value = 0;\n            offset += 3;\n            chLocal = charAt(bp + offset++);\n\n            if (quote && chLocal == '\"') {\n                chLocal = charAt(bp + offset++);\n            }\n\n            for (;;) {\n                if (chLocal == ',') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.COMMA;\n                    return value;\n                } else if (chLocal == '}') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.RBRACE;\n                    return value;\n                } else if (isWhitespace(chLocal)) {\n                    chLocal = charAt(bp + offset++);\n                    continue;\n                }\n                break;\n            }\n            matchStat = NOT_MATCH;\n            return 0;\n        } else {\n            matchStat = NOT_MATCH;\n            return 0;\n        }\n\n        if (chLocal == ',') {\n            bp += offset;\n            this.ch = this.charAt(bp);\n            matchStat = VALUE;\n            token = JSONToken.COMMA;\n            return value;\n        }\n\n        if (chLocal == '}') {\n            chLocal = charAt(bp + (offset++));\n            if (chLocal == ',') {\n                token = JSONToken.COMMA;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == ']') {\n                token = JSONToken.RBRACKET;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == '}') {\n                token = JSONToken.RBRACE;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == EOI) {\n                bp += (offset - 1);\n                token = JSONToken.EOF;\n                ch = EOI;\n            } else {\n                matchStat = NOT_MATCH;\n                return 0;\n            }\n            matchStat = END;\n        } else {\n            matchStat = NOT_MATCH;\n            return 0;\n        }\n\n        return value;\n    }\n",
        "start_line": 2475,
        "end_line": 2476,
        "bug_id": "44",
        "before": "    public final float scanFieldFloat(char[] fieldName) {\n        matchStat = UNKNOWN;\n\n        if (!charArrayCompare(fieldName)) {\n            matchStat = NOT_MATCH_NAME;\n            return 0;\n        }\n\n        int offset = fieldName.length;\n        char chLocal = charAt(bp + (offset++));\n\n        final boolean quote = chLocal == '\"';\n        if (quote) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        boolean negative = chLocal == '-';\n        if (negative) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        float value;\n        if (chLocal >= '0' && chLocal <= '9') {\n            int intVal = chLocal - '0';\n            for (;;) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal >= '0' && chLocal <= '9') {\n                    intVal = intVal * 10 + (chLocal - '0');\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            int power = 1;\n            boolean small = (chLocal == '.');\n            if (small) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal >= '0' && chLocal <= '9') {\n                    intVal = intVal * 10 + (chLocal - '0');\n                    power = 10;\n                    for (;;) {\n                        chLocal = charAt(bp + (offset++));\n                        if (chLocal >= '0' && chLocal <= '9') {\n                            intVal = intVal * 10 + (chLocal - '0');\n                            power *= 10;\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                } else {\n                    matchStat = NOT_MATCH;\n                    return 0;\n                }\n            }\n\n            boolean exp = chLocal == 'e' || chLocal == 'E';\n            if (exp) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal == '+' || chLocal == '-') {\n                    chLocal = charAt(bp + (offset++));\n                }\n                for (;;) {\n                    if (chLocal >= '0' && chLocal <= '9') {\n                        chLocal = charAt(bp + (offset++));\n                    } else {\n                        break;\n                    }\n                }\n            }\n\n            int start, count;\n            if (quote) {\n                if (chLocal != '\"') {\n                    matchStat = NOT_MATCH;\n                    return 0;\n                } else {\n                    chLocal = charAt(bp + (offset++));\n                }\n                start = bp + fieldName.length + 1;\n                count = bp + offset - start - 2;\n            } else {\n                start = bp + fieldName.length;\n                count = bp + offset - start - 1;\n            }\n\n",
        "after": "                value = ((float) intVal) / power;\n                if (negative) {\n                    value = -value;\n                }\n            } else {\n                String text = this.subString(start, count);\n                value = Float.parseFloat(text);\n            }\n        } else if (chLocal == 'n' && charAt(bp + offset) == 'u' && charAt(bp + offset + 1) == 'l' && charAt(bp + offset + 2) == 'l') {\n            matchStat = VALUE_NULL;\n            value = 0;\n            offset += 3;\n            chLocal = charAt(bp + offset++);\n\n            if (quote && chLocal == '\"') {\n                chLocal = charAt(bp + offset++);\n            }\n\n            for (;;) {\n                if (chLocal == ',') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.COMMA;\n                    return value;\n                } else if (chLocal == '}') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.RBRACE;\n                    return value;\n                } else if (isWhitespace(chLocal)) {\n                    chLocal = charAt(bp + offset++);\n                    continue;\n                }\n                break;\n            }\n            matchStat = NOT_MATCH;\n            return 0;\n        } else {\n            matchStat = NOT_MATCH;\n            return 0;\n        }\n\n        if (chLocal == ',') {\n            bp += offset;\n            this.ch = this.charAt(bp);\n            matchStat = VALUE;\n            token = JSONToken.COMMA;\n            return value;\n        }\n\n        if (chLocal == '}') {\n            chLocal = charAt(bp + (offset++));\n            if (chLocal == ',') {\n                token = JSONToken.COMMA;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == ']') {\n                token = JSONToken.RBRACKET;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == '}') {\n                token = JSONToken.RBRACE;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == EOI) {\n                bp += (offset - 1);\n                token = JSONToken.EOF;\n                ch = EOI;\n            } else {\n                matchStat = NOT_MATCH;\n                return 0;\n            }\n            matchStat = END;\n        } else {\n            matchStat = NOT_MATCH;\n            return 0;\n        }\n\n        return value;\n    }\n",
        "buggy_line": "if (!exp && count < 20) {",
        "buggy_lines": "            if (!exp && count < 20) {\n",
        "method_start_line": 2388,
        "method_end_line": 2558
    },
    "46_src/main/java/com/alibaba/fastjson/JSONPath.java": {
        "context": "        Object parseArrayAccessFilter(boolean acceptBracket) {\n            if (acceptBracket) {\n                accept('[');\n            }\n\n            boolean predicateFlag = false;\n            int lparanCount = 0;\n\n            if (ch == '?') {\n                next();\n                accept('(');\n                lparanCount++;\n                while (ch == '(') {\n                    next();\n                    lparanCount++;\n                }\n                predicateFlag = true;\n            }\n\n            //\n\n            if (predicateFlag\n                    || IOUtils.firstIdentifier(ch)\n                    || Character.isJavaIdentifierStart(ch)\n                    || ch == '\\\\'\n                    || ch == '@') {\n                boolean self = false;\n                if (ch == '@') {\n                    next();\n                    accept('.');\n                    self = true;\n                }\n                String propertyName = readName();\n\n                skipWhitespace();\n\n                if (predicateFlag && ch == ')') {\n                    next();\n\n                    Filter filter = new NotNullSegement(propertyName);\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n                    return filter;\n                }\n\n                if (acceptBracket && ch == ']') {\n                    next();\n                    Filter filter = new NotNullSegement(propertyName);\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    accept(')');\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n                    return filter;\n                }\n\n                Operator op = readOp();\n\n                skipWhitespace();\n\n                if (op == Operator.BETWEEN || op == Operator.NOT_BETWEEN) {\n                    final boolean not = (op == Operator.NOT_BETWEEN);\n\n                    Object startValue = readValue();\n\n                    String name = readName();\n\n                    if (!\"and\".equalsIgnoreCase(name)) {\n                        throw new JSONPathException(path);\n                    }\n\n                    Object endValue = readValue();\n\n                    if (startValue == null || endValue == null) {\n                        throw new JSONPathException(path);\n                    }\n\n                    if (isInt(startValue.getClass()) && isInt(endValue.getClass())) {\n                        Filter filter = new IntBetweenSegement(propertyName\n                                , TypeUtils.longExtractValue((Number) startValue)\n                                , TypeUtils.longExtractValue((Number) endValue)\n                                , not);\n                        return filter;\n                    }\n\n                    throw new JSONPathException(path);\n                }\n\n                if (op == Operator.IN || op == Operator.NOT_IN) {\n                    final boolean not = (op == Operator.NOT_IN);\n                    accept('(');\n\n                    List<Object> valueList = new JSONArray();\n                    {\n                        Object value = readValue();\n                        valueList.add(value);\n\n                        for (;;) {\n                            skipWhitespace();\n                            if (ch != ',') {\n                                break;\n                            }\n                            next();\n\n                            value = readValue();\n                            valueList.add(value);\n                        }\n                    }\n\n                    boolean isInt = true;\n                    boolean isIntObj = true;\n                    boolean isString = true;\n                    for (Object item : valueList) {\n                        if (item == null) {\n                            if (isInt) {\n                                isInt = false;\n                            }\n                            continue;\n                        }\n\n                        Class<?> clazz = item.getClass();\n                        if (isInt && !(clazz == Byte.class || clazz == Short.class || clazz == Integer.class\n                                       || clazz == Long.class)) {\n                            isInt = false;\n                            isIntObj = false;\n                        }\n\n                        if (isString && clazz != String.class) {\n                            isString = false;\n                        }\n                    }\n\n                    if (valueList.size() == 1 && valueList.get(0) == null) {\n                        Filter filter;\n                        if (not) {\n                            filter = new NotNullSegement(propertyName);\n                        } else {\n                            filter = new NullSegement(propertyName);\n                        }\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isInt) {\n                        if (valueList.size() == 1) {\n                            long value = TypeUtils.longExtractValue((Number) valueList.get(0));\n                            Operator intOp = not ? Operator.NE : Operator.EQ;\n                            Filter filter = new IntOpSegement(propertyName, value, intOp);\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n\n                            accept(')');\n                            if (predicateFlag) {\n                                accept(')');\n                            }\n\n                            if (acceptBracket) {\n                                accept(']');\n                            }\n\n                            return filter;\n                        }\n\n                        long[] values = new long[valueList.size()];\n                        for (int i = 0; i < values.length; ++i) {\n                            values[i] = TypeUtils.longExtractValue((Number) valueList.get(i));\n                        }\n\n                        Filter filter = new IntInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isString) {\n                        if (valueList.size() == 1) {\n                            String value = (String) valueList.get(0);\n\n                            Operator intOp = not ? Operator.NE : Operator.EQ;\n                            Filter filter = new StringOpSegement(propertyName, value, intOp);\n\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n\n                            accept(')');\n                            if (predicateFlag) {\n                                accept(')');\n                            }\n\n                            if (acceptBracket) {\n                                accept(']');\n                            }\n\n                            return filter;\n                        }\n\n                        String[] values = new String[valueList.size()];\n                        valueList.toArray(values);\n\n                        Filter filter = new StringInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isIntObj) {\n                        Long[] values = new Long[valueList.size()];\n                        for (int i = 0; i < values.length; ++i) {\n                            Number item = (Number) valueList.get(i);\n                            if (item != null) {\n                                values[i] = TypeUtils.longExtractValue(item);\n                            }\n                        }\n\n                        Filter filter = new IntObjInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    throw new UnsupportedOperationException();\n                }\n\n                if (ch == '\\'' || ch == '\"') {\n                    String strValue = readString();\n\n                    Filter filter = null;\n                    if (op == Operator.RLIKE) {\n                        filter = new RlikeSegement(propertyName, strValue, false);\n                    } else if (op == Operator.NOT_RLIKE) {\n                        filter = new RlikeSegement(propertyName, strValue, true);\n                    } else  if (op == Operator.LIKE || op == Operator.NOT_LIKE) {\n                        while (strValue.indexOf(\"%%\") != -1) {\n                            strValue = strValue.replaceAll(\"%%\", \"%\");\n                        }\n\n                        final boolean not = (op == Operator.NOT_LIKE);\n\n                        int p0 = strValue.indexOf('%');\n                        if (p0 == -1) {\n                            if (op == Operator.LIKE) {\n                                op = Operator.EQ;\n                            } else {\n                                op = Operator.NE;\n                            }\n                            filter = new StringOpSegement(propertyName, strValue, op);\n                        } else {\n                            String[] items = strValue.split(\"%\");\n\n                            String startsWithValue = null;\n                            String endsWithValue = null;\n                            String[] containsValues = null;\n                            if (p0 == 0) {\n                                if (strValue.charAt(strValue.length() - 1) == '%') {\n                                    containsValues = new String[items.length - 1];\n                                    System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                } else {\n                                    endsWithValue = items[items.length - 1];\n                                    if (items.length > 2) {\n                                        containsValues = new String[items.length - 2];\n                                        System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                    }\n                                }\n                            } else if (strValue.charAt(strValue.length() - 1) == '%') {\n                                if (items.length == 1) {\n                                    startsWithValue = items[0];\n                                } else {\n                                    containsValues = items;\n                                }\n                            } else {\n                                if (items.length == 1) {\n                                    startsWithValue = items[0];\n                                } else if (items.length == 2) {\n                                    startsWithValue = items[0];\n                                    endsWithValue = items[1];\n                                } else {\n                                    startsWithValue = items[0];\n                                    endsWithValue = items[items.length - 1];\n                                    containsValues = new String[items.length - 2];\n                                    System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                }\n                            }\n\n                            filter = new MatchSegement(propertyName, startsWithValue, endsWithValue,\n                                    containsValues, not);\n                        }\n                    } else {\n                        filter = new StringOpSegement(propertyName, strValue, op);\n                    }\n\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n                    \n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                }\n\n                if (isDigitFirst(ch)) {\n                    long value = readLongValue();\n                    double doubleValue = 0D;\n                    if (ch == '.') {\n                        doubleValue = readDoubleValue(value);\n                        \n                    }\n\n                    Filter filter;\n\n                    if (doubleValue == 0) {\n                        filter = new IntOpSegement(propertyName, value, op);\n                    } else {\n                        filter = new DoubleOpSegement(propertyName, doubleValue, op);\n                    }\n\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (lparanCount > 1 && ch == ')') {\n                        next();\n                        lparanCount--;\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (predicateFlag) {\n                        lparanCount--;\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                } else if (ch == '$') {\n                    Segment segment = readSegement();\n                    RefOpSegement filter = new RefOpSegement(propertyName, segment, op);\n                    hasRefSegment = true;\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                } else if (ch == '/') {\n                    int flags = 0;\n                    StringBuilder regBuf = new StringBuilder();\n                    for (;;) {\n                        next();\n                        if (ch == '/') {\n                            next();\n                            if (ch == 'i') {\n                                next();\n                                flags |= Pattern.CASE_INSENSITIVE;\n                            }\n                            break;\n                        }\n\n                        if (ch == '\\\\') {\n                            next();\n                            regBuf.append(ch);\n                        } else {\n                            regBuf.append(ch);\n                        }\n                    }\n\n                    Pattern pattern = Pattern.compile(regBuf.toString(), flags);\n                    RegMatchSegement filter = new RegMatchSegement(propertyName, pattern, op);\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                }\n\n                if (ch == 'n') {\n                    String name = readName();\n                    if (\"null\".equals(name)) {\n                        Filter filter = null;\n                        if (op == Operator.EQ) {\n                            filter = new NullSegement(propertyName);\n                        } else if (op == Operator.NE) {\n                            filter = new NotNullSegement(propertyName);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                } else if (ch == 't') {\n                    String name = readName();\n                    \n                    if (\"true\".equals(name)) {\n                        Filter filter = null;\n\n                        if (op == Operator.EQ) {\n                            filter = new ValueSegment(propertyName, Boolean.TRUE, true);\n                        } else if (op == Operator.NE) {\n                            filter = new ValueSegment(propertyName, Boolean.TRUE, false);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                } else if (ch == 'f') {\n                    String name = readName();\n                    \n                    if (\"false\".equals(name)) {\n                        Filter filter = null;\n\n                        if (op == Operator.EQ) {\n                            filter = new ValueSegment(propertyName, Boolean.FALSE, true);\n                        } else if (op == Operator.NE) {\n                            filter = new ValueSegment(propertyName, Boolean.FALSE, false);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                }\n\n                throw new UnsupportedOperationException();\n                // accept(')');\n            }\n\n            int start = pos - 1;\n            char startCh = ch;\n            while (ch != ']' && ch != '/' && !isEOF()) {\n                if (ch == '.' //\n                        && (!predicateFlag) // \n                        && !predicateFlag\n                        && startCh != '\\''\n                ) {\n                    break;\n                }\n                \n                if (ch == '\\\\') {\n                    next();\n                }\n                next();\n            }\n            \n            int end;\n            if (acceptBracket) {\n                end = pos - 1;\n            } else {\n                if (ch == '/' || ch == '.') {\n                    end = pos - 1;\n                } else {\n                    end = pos;\n                }\n            }\n            \n            String text = path.substring(start, end);\n            \n            if (text.indexOf(\"\\\\.\") != -1) {\n                String propName;\n                if (startCh == '\\'' && text.length() > 2 && text.charAt(text.length() - 1) == startCh) {\n                    propName = text.substring(1, text.length() - 1);\n                } else {\n                    propName = text.replaceAll(\"\\\\\\\\\\\\.\", \"\\\\.\");\n                    if (propName.indexOf(\"\\\\-\") != -1) {\n                        propName = propName.replaceAll(\"\\\\\\\\-\", \"-\");\n                    }\n                }\n\n                if (predicateFlag) {\n                    accept(')');\n                }\n\n                return new PropertySegment(propName, false);\n            }\n\n            Segment segment = buildArraySegement(text);\n\n            if (acceptBracket && !isEOF()) {\n                accept(']');\n            }\n\n            return segment;\n        }\n",
        "start_line": 1569,
        "end_line": 1569,
        "bug_id": "46",
        "before": "        Object parseArrayAccessFilter(boolean acceptBracket) {\n            if (acceptBracket) {\n                accept('[');\n            }\n\n            boolean predicateFlag = false;\n            int lparanCount = 0;\n\n            if (ch == '?') {\n                next();\n                accept('(');\n                lparanCount++;\n                while (ch == '(') {\n                    next();\n                    lparanCount++;\n                }\n                predicateFlag = true;\n            }\n\n            //\n\n            if (predicateFlag\n                    || IOUtils.firstIdentifier(ch)\n                    || Character.isJavaIdentifierStart(ch)\n                    || ch == '\\\\'\n                    || ch == '@') {\n                boolean self = false;\n                if (ch == '@') {\n                    next();\n                    accept('.');\n                    self = true;\n                }\n                String propertyName = readName();\n\n                skipWhitespace();\n\n                if (predicateFlag && ch == ')') {\n                    next();\n\n                    Filter filter = new NotNullSegement(propertyName);\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n                    return filter;\n                }\n\n                if (acceptBracket && ch == ']') {\n                    next();\n                    Filter filter = new NotNullSegement(propertyName);\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    accept(')');\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n                    return filter;\n                }\n\n                Operator op = readOp();\n\n                skipWhitespace();\n\n                if (op == Operator.BETWEEN || op == Operator.NOT_BETWEEN) {\n                    final boolean not = (op == Operator.NOT_BETWEEN);\n\n                    Object startValue = readValue();\n\n                    String name = readName();\n\n                    if (!\"and\".equalsIgnoreCase(name)) {\n                        throw new JSONPathException(path);\n                    }\n\n                    Object endValue = readValue();\n\n                    if (startValue == null || endValue == null) {\n                        throw new JSONPathException(path);\n                    }\n\n                    if (isInt(startValue.getClass()) && isInt(endValue.getClass())) {\n                        Filter filter = new IntBetweenSegement(propertyName\n                                , TypeUtils.longExtractValue((Number) startValue)\n                                , TypeUtils.longExtractValue((Number) endValue)\n                                , not);\n                        return filter;\n                    }\n\n                    throw new JSONPathException(path);\n                }\n\n                if (op == Operator.IN || op == Operator.NOT_IN) {\n                    final boolean not = (op == Operator.NOT_IN);\n                    accept('(');\n\n                    List<Object> valueList = new JSONArray();\n                    {\n                        Object value = readValue();\n                        valueList.add(value);\n\n                        for (;;) {\n                            skipWhitespace();\n                            if (ch != ',') {\n                                break;\n                            }\n                            next();\n\n                            value = readValue();\n                            valueList.add(value);\n                        }\n                    }\n\n                    boolean isInt = true;\n                    boolean isIntObj = true;\n                    boolean isString = true;\n                    for (Object item : valueList) {\n                        if (item == null) {\n                            if (isInt) {\n                                isInt = false;\n                            }\n                            continue;\n                        }\n\n                        Class<?> clazz = item.getClass();\n                        if (isInt && !(clazz == Byte.class || clazz == Short.class || clazz == Integer.class\n                                       || clazz == Long.class)) {\n                            isInt = false;\n                            isIntObj = false;\n                        }\n\n                        if (isString && clazz != String.class) {\n                            isString = false;\n                        }\n                    }\n\n                    if (valueList.size() == 1 && valueList.get(0) == null) {\n                        Filter filter;\n                        if (not) {\n                            filter = new NotNullSegement(propertyName);\n                        } else {\n                            filter = new NullSegement(propertyName);\n                        }\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isInt) {\n                        if (valueList.size() == 1) {\n                            long value = TypeUtils.longExtractValue((Number) valueList.get(0));\n                            Operator intOp = not ? Operator.NE : Operator.EQ;\n                            Filter filter = new IntOpSegement(propertyName, value, intOp);\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n\n                            accept(')');\n                            if (predicateFlag) {\n                                accept(')');\n                            }\n\n                            if (acceptBracket) {\n                                accept(']');\n                            }\n\n                            return filter;\n                        }\n\n                        long[] values = new long[valueList.size()];\n                        for (int i = 0; i < values.length; ++i) {\n                            values[i] = TypeUtils.longExtractValue((Number) valueList.get(i));\n                        }\n\n                        Filter filter = new IntInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isString) {\n                        if (valueList.size() == 1) {\n                            String value = (String) valueList.get(0);\n\n                            Operator intOp = not ? Operator.NE : Operator.EQ;\n                            Filter filter = new StringOpSegement(propertyName, value, intOp);\n\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n\n                            accept(')');\n                            if (predicateFlag) {\n                                accept(')');\n                            }\n\n                            if (acceptBracket) {\n                                accept(']');\n                            }\n\n                            return filter;\n                        }\n\n                        String[] values = new String[valueList.size()];\n                        valueList.toArray(values);\n\n                        Filter filter = new StringInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isIntObj) {\n                        Long[] values = new Long[valueList.size()];\n                        for (int i = 0; i < values.length; ++i) {\n                            Number item = (Number) valueList.get(i);\n                            if (item != null) {\n                                values[i] = TypeUtils.longExtractValue(item);\n                            }\n                        }\n\n                        Filter filter = new IntObjInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    throw new UnsupportedOperationException();\n                }\n\n                if (ch == '\\'' || ch == '\"') {\n                    String strValue = readString();\n\n                    Filter filter = null;\n                    if (op == Operator.RLIKE) {\n                        filter = new RlikeSegement(propertyName, strValue, false);\n                    } else if (op == Operator.NOT_RLIKE) {\n                        filter = new RlikeSegement(propertyName, strValue, true);\n                    } else  if (op == Operator.LIKE || op == Operator.NOT_LIKE) {\n                        while (strValue.indexOf(\"%%\") != -1) {\n                            strValue = strValue.replaceAll(\"%%\", \"%\");\n                        }\n\n                        final boolean not = (op == Operator.NOT_LIKE);\n\n                        int p0 = strValue.indexOf('%');\n                        if (p0 == -1) {\n                            if (op == Operator.LIKE) {\n                                op = Operator.EQ;\n                            } else {\n                                op = Operator.NE;\n                            }\n                            filter = new StringOpSegement(propertyName, strValue, op);\n                        } else {\n                            String[] items = strValue.split(\"%\");\n\n                            String startsWithValue = null;\n                            String endsWithValue = null;\n                            String[] containsValues = null;\n                            if (p0 == 0) {\n                                if (strValue.charAt(strValue.length() - 1) == '%') {\n                                    containsValues = new String[items.length - 1];\n                                    System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                } else {\n                                    endsWithValue = items[items.length - 1];\n                                    if (items.length > 2) {\n                                        containsValues = new String[items.length - 2];\n                                        System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                    }\n                                }\n                            } else if (strValue.charAt(strValue.length() - 1) == '%') {\n                                if (items.length == 1) {\n                                    startsWithValue = items[0];\n                                } else {\n                                    containsValues = items;\n                                }\n                            } else {\n                                if (items.length == 1) {\n                                    startsWithValue = items[0];\n                                } else if (items.length == 2) {\n                                    startsWithValue = items[0];\n                                    endsWithValue = items[1];\n                                } else {\n                                    startsWithValue = items[0];\n                                    endsWithValue = items[items.length - 1];\n                                    containsValues = new String[items.length - 2];\n                                    System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                }\n                            }\n\n                            filter = new MatchSegement(propertyName, startsWithValue, endsWithValue,\n                                    containsValues, not);\n                        }\n                    } else {\n                        filter = new StringOpSegement(propertyName, strValue, op);\n                    }\n\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n                    \n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                }\n\n                if (isDigitFirst(ch)) {\n                    long value = readLongValue();\n                    double doubleValue = 0D;\n                    if (ch == '.') {\n                        doubleValue = readDoubleValue(value);\n                        \n                    }\n\n                    Filter filter;\n\n                    if (doubleValue == 0) {\n                        filter = new IntOpSegement(propertyName, value, op);\n                    } else {\n                        filter = new DoubleOpSegement(propertyName, doubleValue, op);\n                    }\n\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (lparanCount > 1 && ch == ')') {\n                        next();\n                        lparanCount--;\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (predicateFlag) {\n                        lparanCount--;\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                } else if (ch == '$') {\n                    Segment segment = readSegement();\n                    RefOpSegement filter = new RefOpSegement(propertyName, segment, op);\n                    hasRefSegment = true;\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                } else if (ch == '/') {\n                    int flags = 0;\n                    StringBuilder regBuf = new StringBuilder();\n                    for (;;) {\n                        next();\n                        if (ch == '/') {\n                            next();\n                            if (ch == 'i') {\n                                next();\n                                flags |= Pattern.CASE_INSENSITIVE;\n                            }\n                            break;\n                        }\n\n                        if (ch == '\\\\') {\n                            next();\n                            regBuf.append(ch);\n                        } else {\n                            regBuf.append(ch);\n                        }\n                    }\n\n                    Pattern pattern = Pattern.compile(regBuf.toString(), flags);\n                    RegMatchSegement filter = new RegMatchSegement(propertyName, pattern, op);\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                }\n\n                if (ch == 'n') {\n                    String name = readName();\n                    if (\"null\".equals(name)) {\n                        Filter filter = null;\n                        if (op == Operator.EQ) {\n                            filter = new NullSegement(propertyName);\n                        } else if (op == Operator.NE) {\n                            filter = new NotNullSegement(propertyName);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                } else if (ch == 't') {\n                    String name = readName();\n                    \n                    if (\"true\".equals(name)) {\n                        Filter filter = null;\n\n                        if (op == Operator.EQ) {\n                            filter = new ValueSegment(propertyName, Boolean.TRUE, true);\n                        } else if (op == Operator.NE) {\n                            filter = new ValueSegment(propertyName, Boolean.TRUE, false);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                } else if (ch == 'f') {\n                    String name = readName();\n                    \n                    if (\"false\".equals(name)) {\n                        Filter filter = null;\n\n                        if (op == Operator.EQ) {\n                            filter = new ValueSegment(propertyName, Boolean.FALSE, true);\n                        } else if (op == Operator.NE) {\n                            filter = new ValueSegment(propertyName, Boolean.FALSE, false);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                }\n\n                throw new UnsupportedOperationException();\n                // accept(')');\n            }\n\n            int start = pos - 1;\n            char startCh = ch;\n            while (ch != ']' && ch != '/' && !isEOF()) {\n                if (ch == '.' //\n                        && (!predicateFlag) // \n                        && !predicateFlag\n                        && startCh != '\\''\n                ) {\n                    break;\n                }\n                \n                if (ch == '\\\\') {\n                    next();\n                }\n                next();\n            }\n            \n            int end;\n            if (acceptBracket) {\n                end = pos - 1;\n            } else {\n                if (ch == '/' || ch == '.') {\n                    end = pos - 1;\n                } else {\n                    end = pos;\n                }\n            }\n            \n            String text = path.substring(start, end);\n",
        "after": "            \n            if (text.indexOf(\"\\\\.\") != -1) {\n                String propName;\n                if (startCh == '\\'' && text.length() > 2 && text.charAt(text.length() - 1) == startCh) {\n                    propName = text.substring(1, text.length() - 1);\n                } else {\n                    propName = text.replaceAll(\"\\\\\\\\\\\\.\", \"\\\\.\");\n                    if (propName.indexOf(\"\\\\-\") != -1) {\n                        propName = propName.replaceAll(\"\\\\\\\\-\", \"-\");\n                    }\n                }\n\n                if (predicateFlag) {\n                    accept(')');\n                }\n\n                return new PropertySegment(propName, false);\n            }\n\n            Segment segment = buildArraySegement(text);\n\n            if (acceptBracket && !isEOF()) {\n                accept(']');\n            }\n\n            return segment;\n        }\n",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 941,
        "method_end_line": 1596
    },
    "47_src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java": {
        "context": "    public Object createInstance(Map<String, Object> map, ParserConfig config) //\n                                                                               throws IllegalArgumentException,\n                                                                               IllegalAccessException,\n                                                                               InvocationTargetException {\n        Object object = null;\n        \n        if (beanInfo.creatorConstructor == null && beanInfo.factoryMethod == null) {\n            object = createInstance(null, clazz);\n            \n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser == null) {\n                    continue;\n                }\n\n                final FieldInfo fieldInfo = fieldDeser.fieldInfo;\n                Field field = fieldDeser.fieldInfo.field;\n                Type paramType = fieldInfo.fieldType;\n\n                if (fieldInfo.declaringClass != null\n                        && fieldInfo.getAnnotation() != null\n                        && fieldInfo.getAnnotation().deserializeUsing() != Void.class\n                        && fieldInfo.fieldClass.isInstance(value)) {\n                    DefaultJSONParser parser = new DefaultJSONParser(JSON.toJSONString(value));\n                    fieldDeser.parseField(parser, object, paramType, null);\n                    continue;\n                }\n\n                if (field != null) {\n                    Class fieldType = field.getType();\n                    if (fieldType == boolean.class) {\n                        if (value == Boolean.FALSE) {\n                            field.setBoolean(object, false);\n                            continue;\n                        }\n\n                        if (value == Boolean.TRUE) {\n                            field.setBoolean(object, true);\n                            continue;\n                        }\n                    } else if (fieldType == int.class) {\n                        if (value instanceof Number) {\n                            field.setInt(object, ((Number) value).intValue());\n                            continue;\n                        }\n                    } else if (fieldType == long.class) {\n                        if (value instanceof Number) {\n                            field.setLong(object, ((Number) value).longValue());\n                            continue;\n                        }\n                    } else if (fieldType == float.class) {\n                        if (value instanceof Number) {\n                            field.setFloat(object, ((Number) value).floatValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            float floatValue;\n                            if (strVal.length() <= 10) {\n                                floatValue = TypeUtils.parseFloat(strVal);\n                            } else {\n                                floatValue = Float.parseFloat(strVal);\n                            }\n\n                            field.setFloat(object, floatValue);\n                            continue;\n                        }\n                    } else if (fieldType == double.class) {\n                        if (value instanceof Number) {\n                            field.setDouble(object, ((Number) value).doubleValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            double doubleValue;\n                            if (strVal.length() <= 10) {\n                                doubleValue = TypeUtils.parseDouble(strVal);\n                            } else {\n                                doubleValue = Double.parseDouble(strVal);\n                            }\n\n                            field.setDouble(object, doubleValue);\n                            continue;\n                        }\n                    } else if (value != null && paramType == value.getClass()) {\n                        field.set(object, value);\n                        continue;\n                    }\n                }\n\n                String format = fieldInfo.format;\n                if (format != null && paramType == Date.class) {\n                    value = TypeUtils.castToDate(value, format);\n                } else if (format != null && (paramType instanceof Class) && (((Class) paramType).getName().equals(\"java.time.LocalDateTime\"))) {\n                    value = TypeUtils.castToLocalDateTime(value, format);\n                } else {\n                    if (paramType instanceof ParameterizedType) {\n                        value = TypeUtils.cast(value, (ParameterizedType) paramType, config);\n                    } else {\n                        value = TypeUtils.cast(value, paramType, config);\n                    }\n                }\n\n                fieldDeser.setValue(object, value);\n            }\n\n            if (beanInfo.buildMethod != null) {\n                Object builtObj;\n                try {\n                    builtObj = beanInfo.buildMethod.invoke(object);\n                } catch (Exception e) {\n                    throw new JSONException(\"build object error\", e);\n                }\n\n                return builtObj;\n            }\n\n            return object;\n        }\n\n        \n        FieldInfo[] fieldInfoList = beanInfo.fields;\n        int size = fieldInfoList.length;\n        Object[] params = new Object[size];\n        Map<String, Integer> missFields = null;\n        for (int i = 0; i < size; ++i) {\n            FieldInfo fieldInfo = fieldInfoList[i];\n            Object param = map.get(fieldInfo.name);\n\n            if (param == null) {\n                Class<?> fieldClass = fieldInfo.fieldClass;\n                if (fieldClass == int.class) {\n                    param = 0;\n                } else if (fieldClass == long.class) {\n                    param = 0L;\n                } else if (fieldClass == short.class) {\n                    param = Short.valueOf((short) 0);\n                } else if (fieldClass == byte.class) {\n                    param = Byte.valueOf((byte) 0);\n                } else if (fieldClass == float.class) {\n                    param = Float.valueOf(0);\n                } else if (fieldClass == double.class) {\n                    param = Double.valueOf(0);\n                } else if (fieldClass == char.class) {\n                    param = '0';\n                } else if (fieldClass == boolean.class) {\n                    param = false;\n                }\n                if (missFields == null) {\n                    missFields = new HashMap<String, Integer>();\n                }\n                missFields.put(fieldInfo.name, i);\n            }\n            params[i] = param;\n        }\n\n        if (missFields != null) {\n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser != null) {\n                    Integer index = missFields.get(fieldDeser.fieldInfo.name);\n                    if (index != null) {\n                        params[index] = value;\n                    }\n                }\n            }\n        }\n\n        if (beanInfo.creatorConstructor != null) {\n            boolean hasNull = false;\n            if (beanInfo.kotlin) {\n                for (int i = 0; i < params.length; i++) {\n                    if (params[i] == null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                        FieldInfo fieldInfo = beanInfo.fields[i];\n                        if (fieldInfo.fieldClass == String.class) {\n                            hasNull = true;\n                        }\n                        break;\n                    }\n                }\n            }\n\n            if (hasNull && beanInfo.kotlinDefaultConstructor != null) {\n                try {\n                    object = beanInfo.kotlinDefaultConstructor.newInstance();\n\n                    for (int i = 0; i < params.length; i++) {\n                        final Object param = params[i];\n                        if (param != null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                            FieldInfo fieldInfo = beanInfo.fields[i];\n                            fieldInfo.set(object, param);\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            } else {\n                try {\n                    object = beanInfo.creatorConstructor.newInstance(params);\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            }\n        } else if (beanInfo.factoryMethod != null) {\n            try {\n                object = beanInfo.factoryMethod.invoke(null, params);\n            } catch (Exception e) {\n                throw new JSONException(\"create factory method error, \" + beanInfo.factoryMethod.toString(), e);\n            }\n        }\n        \n        return object;\n    }\n",
        "start_line": 1373,
        "end_line": 1374,
        "bug_id": "47",
        "before": "    public Object createInstance(Map<String, Object> map, ParserConfig config) //\n                                                                               throws IllegalArgumentException,\n                                                                               IllegalAccessException,\n                                                                               InvocationTargetException {\n        Object object = null;\n        \n        if (beanInfo.creatorConstructor == null && beanInfo.factoryMethod == null) {\n            object = createInstance(null, clazz);\n            \n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser == null) {\n                    continue;\n                }\n\n                final FieldInfo fieldInfo = fieldDeser.fieldInfo;\n                Field field = fieldDeser.fieldInfo.field;\n                Type paramType = fieldInfo.fieldType;\n\n                if (fieldInfo.declaringClass != null\n                        && fieldInfo.getAnnotation() != null\n                        && fieldInfo.getAnnotation().deserializeUsing() != Void.class\n                        && fieldInfo.fieldClass.isInstance(value)) {\n                    DefaultJSONParser parser = new DefaultJSONParser(JSON.toJSONString(value));\n                    fieldDeser.parseField(parser, object, paramType, null);\n                    continue;\n                }\n\n",
        "after": "                    Class fieldType = field.getType();\n                    if (fieldType == boolean.class) {\n                        if (value == Boolean.FALSE) {\n                            field.setBoolean(object, false);\n                            continue;\n                        }\n\n                        if (value == Boolean.TRUE) {\n                            field.setBoolean(object, true);\n                            continue;\n                        }\n                    } else if (fieldType == int.class) {\n                        if (value instanceof Number) {\n                            field.setInt(object, ((Number) value).intValue());\n                            continue;\n                        }\n                    } else if (fieldType == long.class) {\n                        if (value instanceof Number) {\n                            field.setLong(object, ((Number) value).longValue());\n                            continue;\n                        }\n                    } else if (fieldType == float.class) {\n                        if (value instanceof Number) {\n                            field.setFloat(object, ((Number) value).floatValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            float floatValue;\n                            if (strVal.length() <= 10) {\n                                floatValue = TypeUtils.parseFloat(strVal);\n                            } else {\n                                floatValue = Float.parseFloat(strVal);\n                            }\n\n                            field.setFloat(object, floatValue);\n                            continue;\n                        }\n                    } else if (fieldType == double.class) {\n                        if (value instanceof Number) {\n                            field.setDouble(object, ((Number) value).doubleValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            double doubleValue;\n                            if (strVal.length() <= 10) {\n                                doubleValue = TypeUtils.parseDouble(strVal);\n                            } else {\n                                doubleValue = Double.parseDouble(strVal);\n                            }\n\n                            field.setDouble(object, doubleValue);\n                            continue;\n                        }\n                    } else if (value != null && paramType == value.getClass()) {\n                        field.set(object, value);\n                        continue;\n                    }\n                }\n\n                String format = fieldInfo.format;\n                if (format != null && paramType == Date.class) {\n                    value = TypeUtils.castToDate(value, format);\n                } else if (format != null && (paramType instanceof Class) && (((Class) paramType).getName().equals(\"java.time.LocalDateTime\"))) {\n                    value = TypeUtils.castToLocalDateTime(value, format);\n                } else {\n                    if (paramType instanceof ParameterizedType) {\n                        value = TypeUtils.cast(value, (ParameterizedType) paramType, config);\n                    } else {\n                        value = TypeUtils.cast(value, paramType, config);\n                    }\n                }\n\n                fieldDeser.setValue(object, value);\n            }\n\n            if (beanInfo.buildMethod != null) {\n                Object builtObj;\n                try {\n                    builtObj = beanInfo.buildMethod.invoke(object);\n                } catch (Exception e) {\n                    throw new JSONException(\"build object error\", e);\n                }\n\n                return builtObj;\n            }\n\n            return object;\n        }\n\n        \n        FieldInfo[] fieldInfoList = beanInfo.fields;\n        int size = fieldInfoList.length;\n        Object[] params = new Object[size];\n        Map<String, Integer> missFields = null;\n        for (int i = 0; i < size; ++i) {\n            FieldInfo fieldInfo = fieldInfoList[i];\n            Object param = map.get(fieldInfo.name);\n\n            if (param == null) {\n                Class<?> fieldClass = fieldInfo.fieldClass;\n                if (fieldClass == int.class) {\n                    param = 0;\n                } else if (fieldClass == long.class) {\n                    param = 0L;\n                } else if (fieldClass == short.class) {\n                    param = Short.valueOf((short) 0);\n                } else if (fieldClass == byte.class) {\n                    param = Byte.valueOf((byte) 0);\n                } else if (fieldClass == float.class) {\n                    param = Float.valueOf(0);\n                } else if (fieldClass == double.class) {\n                    param = Double.valueOf(0);\n                } else if (fieldClass == char.class) {\n                    param = '0';\n                } else if (fieldClass == boolean.class) {\n                    param = false;\n                }\n                if (missFields == null) {\n                    missFields = new HashMap<String, Integer>();\n                }\n                missFields.put(fieldInfo.name, i);\n            }\n            params[i] = param;\n        }\n\n        if (missFields != null) {\n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser != null) {\n                    Integer index = missFields.get(fieldDeser.fieldInfo.name);\n                    if (index != null) {\n                        params[index] = value;\n                    }\n                }\n            }\n        }\n\n        if (beanInfo.creatorConstructor != null) {\n            boolean hasNull = false;\n            if (beanInfo.kotlin) {\n                for (int i = 0; i < params.length; i++) {\n                    if (params[i] == null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                        FieldInfo fieldInfo = beanInfo.fields[i];\n                        if (fieldInfo.fieldClass == String.class) {\n                            hasNull = true;\n                        }\n                        break;\n                    }\n                }\n            }\n\n            if (hasNull && beanInfo.kotlinDefaultConstructor != null) {\n                try {\n                    object = beanInfo.kotlinDefaultConstructor.newInstance();\n\n                    for (int i = 0; i < params.length; i++) {\n                        final Object param = params[i];\n                        if (param != null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                            FieldInfo fieldInfo = beanInfo.fields[i];\n                            fieldInfo.set(object, param);\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            } else {\n                try {\n                    object = beanInfo.creatorConstructor.newInstance(params);\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            }\n        } else if (beanInfo.factoryMethod != null) {\n            try {\n                object = beanInfo.factoryMethod.invoke(null, params);\n            } catch (Exception e) {\n                throw new JSONException(\"create factory method error, \" + beanInfo.factoryMethod.toString(), e);\n            }\n        }\n        \n        return object;\n    }\n",
        "buggy_line": "if (field != null) {",
        "buggy_lines": "                if (field != null) {\n",
        "method_start_line": 1342,
        "method_end_line": 1561
    },
    "48_src/main/java/org/apache/commons/jexl3/internal/InterpreterBase.java": {
        "context": "    protected Object getVariable(Frame frame, LexicalScope block, ASTIdentifier identifier) {\n        int symbol = identifier.getSymbol();\n        // if we have a symbol, we have a scope thus a frame\n        if (options.isLexicalShade() && identifier.isShaded()) {\n            return undefinedVariable(identifier, identifier.getName());\n        }\n        if (symbol >= 0) {\n            if (frame.has(symbol)) {\n                Object value = frame.get(symbol);\n                if (value != Scope.UNDEFINED) {\n                    return value;\n                }\n            }\n        }\n        String name = identifier.getName();\n        Object value = context.get(name);\n        if (value == null\n            && !(identifier.jjtGetParent() instanceof ASTReference)\n            && !(context.has(name))) {\n                return isSafe()\n                    ? null\n                    : unsolvableVariable(identifier, name, true); // undefined\n        }\n        return value;\n    }\n",
        "start_line": 295,
        "end_line": 298,
        "bug_id": "48",
        "before": "    protected Object getVariable(Frame frame, LexicalScope block, ASTIdentifier identifier) {\n        int symbol = identifier.getSymbol();\n        // if we have a symbol, we have a scope thus a frame\n        if (options.isLexicalShade() && identifier.isShaded()) {\n            return undefinedVariable(identifier, identifier.getName());\n        }\n        if (symbol >= 0) {\n            if (frame.has(symbol)) {\n                Object value = frame.get(symbol);\n                if (value != Scope.UNDEFINED) {\n                    return value;\n                }\n            }\n        }\n        String name = identifier.getName();\n        Object value = context.get(name);\n        if (value == null\n            && !(identifier.jjtGetParent() instanceof ASTReference)\n            && !(context.has(name))) {\n",
        "after": "        }\n        return value;\n    }\n",
        "buggy_line": "return isSafe()                    ? null                    : unsolvableVariable(identifier, name, true); // undefined",
        "buggy_lines": "                return isSafe()\n                    ? null\n                    : unsolvableVariable(identifier, name, true); // undefined\n",
        "method_start_line": 276,
        "method_end_line": 301
    },
    "52_src/main/java/com/yahoo/sketches/theta/UnionImpl.java": {
        "context": "  public void update(final Sketch sketchIn) { //Only valid for theta Sketches using SerVer = 3\n    //UNION Empty Rule: AND the empty states.\n\n    if ((sketchIn == null) || sketchIn.isEmpty()) {\n      //null and empty is interpreted as (Theta = 1.0, count = 0, empty = T).  Nothing changes\n      return;\n    }\n    //sketchIn is valid and not empty\n    Util.checkSeedHashes(seedHash_, sketchIn.getSeedHash());\n    Sketch.checkSketchAndMemoryFlags(sketchIn);\n\n    unionThetaLong_ = min(unionThetaLong_, sketchIn.getThetaLong()); //Theta rule\n    unionEmpty_ = unionEmpty_ && sketchIn.isEmpty();\n    final int curCountIn = sketchIn.getRetainedEntries(true);\n    if (curCountIn > 0) {\n      if (sketchIn.isOrdered()) { //Only true if Compact. Use early stop\n        //Ordered, thus compact\n        if (sketchIn.hasMemory()) {\n          final Memory skMem = ((CompactSketch) sketchIn).getMemory();\n          final int preambleLongs = skMem.getByte(PREAMBLE_LONGS_BYTE) & 0X3F;\n          for (int i = 0; i < curCountIn; i++ ) {\n            final int offsetBytes = (preambleLongs + i) << 3;\n            final long hashIn = skMem.getLong(offsetBytes);\n            if (hashIn >= unionThetaLong_) { break; } // \"early stop\"\n            gadget_.hashUpdate(hashIn); //backdoor update, hash function is bypassed\n          }\n        }\n        else { //sketchIn is on the Java Heap or has array\n          final long[] cacheIn = sketchIn.getCache(); //not a copy!\n          for (int i = 0; i < curCountIn; i++ ) {\n            final long hashIn = cacheIn[i];\n            if (hashIn >= unionThetaLong_) { break; } // \"early stop\"\n            gadget_.hashUpdate(hashIn); //backdoor update, hash function is bypassed\n          }\n        }\n      } //End ordered, compact\n      else { //either not-ordered compact or Hash Table form. A HT may have dirty values.\n        final long[] cacheIn = sketchIn.getCache(); //if off-heap this will be a copy\n        final int arrLongs = cacheIn.length;\n        for (int i = 0, c = 0; (i < arrLongs) && (c < curCountIn); i++ ) {\n          final long hashIn = cacheIn[i];\n          if ((hashIn <= 0L) || (hashIn >= unionThetaLong_)) { continue; } //rejects dirty values\n          gadget_.hashUpdate(hashIn); //backdoor update, hash function is bypassed\n          c++; //insures against invalid state inside the incoming sketch\n        }\n      }\n    }\n    unionThetaLong_ = min(unionThetaLong_, gadget_.getThetaLong()); //Theta rule with gadget\n  }\n",
        "start_line": 304,
        "end_line": 304,
        "bug_id": "52",
        "before": "  public void update(final Sketch sketchIn) { //Only valid for theta Sketches using SerVer = 3\n    //UNION Empty Rule: AND the empty states.\n\n    if ((sketchIn == null) || sketchIn.isEmpty()) {\n      //null and empty is interpreted as (Theta = 1.0, count = 0, empty = T).  Nothing changes\n      return;\n    }\n    //sketchIn is valid and not empty\n    Util.checkSeedHashes(seedHash_, sketchIn.getSeedHash());\n    Sketch.checkSketchAndMemoryFlags(sketchIn);\n\n    unionThetaLong_ = min(unionThetaLong_, sketchIn.getThetaLong()); //Theta rule\n    unionEmpty_ = unionEmpty_ && sketchIn.isEmpty();\n    final int curCountIn = sketchIn.getRetainedEntries(true);\n    if (curCountIn > 0) {\n      if (sketchIn.isOrdered()) { //Only true if Compact. Use early stop\n        //Ordered, thus compact\n        if (sketchIn.hasMemory()) {\n          final Memory skMem = ((CompactSketch) sketchIn).getMemory();\n          final int preambleLongs = skMem.getByte(PREAMBLE_LONGS_BYTE) & 0X3F;\n          for (int i = 0; i < curCountIn; i++ ) {\n            final int offsetBytes = (preambleLongs + i) << 3;\n            final long hashIn = skMem.getLong(offsetBytes);\n            if (hashIn >= unionThetaLong_) { break; } // \"early stop\"\n            gadget_.hashUpdate(hashIn); //backdoor update, hash function is bypassed\n          }\n        }\n        else { //sketchIn is on the Java Heap or has array\n          final long[] cacheIn = sketchIn.getCache(); //not a copy!\n          for (int i = 0; i < curCountIn; i++ ) {\n            final long hashIn = cacheIn[i];\n            if (hashIn >= unionThetaLong_) { break; } // \"early stop\"\n            gadget_.hashUpdate(hashIn); //backdoor update, hash function is bypassed\n          }\n        }\n      } //End ordered, compact\n      else { //either not-ordered compact or Hash Table form. A HT may have dirty values.\n        final long[] cacheIn = sketchIn.getCache(); //if off-heap this will be a copy\n        final int arrLongs = cacheIn.length;\n        for (int i = 0, c = 0; (i < arrLongs) && (c < curCountIn); i++ ) {\n          final long hashIn = cacheIn[i];\n          if ((hashIn <= 0L) || (hashIn >= unionThetaLong_)) { continue; } //rejects dirty values\n          gadget_.hashUpdate(hashIn); //backdoor update, hash function is bypassed\n          c++; //insures against invalid state inside the incoming sketch\n        }\n      }\n    }\n    unionThetaLong_ = min(unionThetaLong_, gadget_.getThetaLong()); //Theta rule with gadget\n",
        "after": "  }\n",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 255,
        "method_end_line": 305
    },
    "54_src/main/java/com/univocity/parsers/common/AbstractWriter.java": {
        "context": "\t@Override\n\tprivate <T> void fillOutputRow(T[] row) {\n\t\tif (!columnReorderingEnabled && row.length > outputRow.length) {\n\t\t\toutputRow = Arrays.copyOf(outputRow, row.length);\n\t\t}\n\t\tif (indexesToWrite.length < row.length) {\n\t\t\tfor (int i = 0; i < indexesToWrite.length; i++) {\n\t\t\t\toutputRow[indexesToWrite[i]] = row[indexesToWrite[i]];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < row.length && i < indexesToWrite.length; i++) {\n\t\t\t\tif (indexesToWrite[i] != -1) {\n\t\t\t\t\toutputRow[indexesToWrite[i]] = row[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
        "start_line": 913,
        "end_line": 914,
        "bug_id": "54",
        "before": "\t@Override\n\tprivate <T> void fillOutputRow(T[] row) {\n\t\tif (!columnReorderingEnabled && row.length > outputRow.length) {\n\t\t\toutputRow = Arrays.copyOf(outputRow, row.length);\n\t\t}\n\t\tif (indexesToWrite.length < row.length) {\n\t\t\tfor (int i = 0; i < indexesToWrite.length; i++) {\n",
        "after": "\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < row.length && i < indexesToWrite.length; i++) {\n\t\t\t\tif (indexesToWrite[i] != -1) {\n\t\t\t\t\toutputRow[indexesToWrite[i]] = row[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
        "buggy_line": "outputRow[indexesToWrite[i]] = row[indexesToWrite[i]];",
        "buggy_lines": "\t\t\t\toutputRow[indexesToWrite[i]] = row[indexesToWrite[i]];\n",
        "method_start_line": 907,
        "method_end_line": 923
    },
    "55_src/main/java/com/univocity/parsers/csv/CsvFormatDetector.java": {
        "context": "\t@Override\n\tpublic void execute(char[] characters, int length) {\n\n\t\tSet<Character> allSymbols = new HashSet<Character>();\n\t\tMap<Character, Integer> symbols = new HashMap<Character, Integer>();\n\t\tMap<Character, Integer> escape = new HashMap<Character, Integer>();\n\t\tList<Map<Character, Integer>> symbolsPerRow = new ArrayList<Map<Character, Integer>>();\n\n\t\tint doubleQuoteCount = 0;\n\t\tint singleQuoteCount = 0;\n\n\t\tint i;\n\t\tchar inQuote = '\\0';\n\t\tboolean afterNewLine = true;\n\t\tfor (i = 0; i < length; i++) {\n\n\t\t\tchar ch = characters[i];\n\n\t\t\tif (afterNewLine && ch == comment) {\n\t\t\t\twhile (++i < length) {\n\t\t\t\t\tch = characters[i];\n\t\t\t\t\tif (ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) {\n\t\t\t\t\t\tif (ch == '\\r' && i + 1 < characters.length && characters[i + 1] == '\\n') {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ch == '\"' || ch == '\\'') {\n\t\t\t\tif (inQuote == ch) { //closing quotes (potentially)\n\t\t\t\t\tif (ch == '\"') {\n\t\t\t\t\t\tdoubleQuoteCount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsingleQuoteCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i + 1 < length) {\n\t\t\t\t\t\tchar next = characters[i + 1];\n\t\t\t\t\t\tif (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\\n' && next != '\\r')) { //no special characters after quote, might be escaping\n\t\t\t\t\t\t\t//special character before (potentially) closing quote, might be an escape\n\t\t\t\t\t\t\tchar prev = characters[i - 1];\n\t\t\t\t\t\t\tif (!Character.isLetterOrDigit(prev) && prev != '\\n' && prev != '\\r') {\n\t\t\t\t\t\t\t\tincrement(escape, prev);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tinQuote = '\\0';\n\t\t\t\t} else if (inQuote == '\\0') {\n\t\t\t\t\tchar prev = '\\0';\n\t\t\t\t\tint j = i;\n\t\t\t\t\twhile (prev <= ' ' && --j >= 0) {\n\t\t\t\t\t\tprev = characters[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j < 0 || !Character.isLetterOrDigit(prev)) {\n\t\t\t\t\t\tinQuote = ch;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inQuote != '\\0') { //keep looping until the quote is closed.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tafterNewLine = false;\n\n\t\t\tif (isSymbol(ch)) { //counts all symbols. Skips letters and digits\n\t\t\t\tallSymbols.add(ch);\n\t\t\t\tincrement(symbols, ch);\n\t\t\t} else if ((ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) && symbols.size() > 0) { //got a newline and collected some symbols? Good!\n\t\t\t\tafterNewLine = true;\n\t\t\t\tsymbolsPerRow.add(symbols);\n\t\t\t\tif (symbolsPerRow.size() == MAX_ROW_SAMPLES) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsymbols = new HashMap<Character, Integer>();\n\t\t\t}\n\t\t}\n\n\t\tif (symbols.size() > 0 && length < characters.length) {\n\t\t\tsymbolsPerRow.add(symbols);\n\t\t}\n\n\t\tif (length >= characters.length && i >= length && symbolsPerRow.size() > 1) { // if got to the end of the buffer, discard last row. It's probably incomplete anyway.\n\t\t\tsymbolsPerRow.remove(symbolsPerRow.size() - 1);\n\t\t}\n\n\t\tMap<Character, Integer> totals = calculateTotals(symbolsPerRow);\n\n\t\tMap<Character, Integer> sums = new HashMap<Character, Integer>();\n\t\tSet<Character> toRemove = new HashSet<Character>();\n\n\t\t//combines the number of symbols found in each row and sums the difference.\n\t\tfor (Map<Character, Integer> previous : symbolsPerRow) {\n\t\t\tfor (Map<Character, Integer> current : symbolsPerRow) {\n\t\t\t\tfor (Character symbol : allSymbols) {\n\t\t\t\t\tInteger previousCount = previous.get(symbol);\n\t\t\t\t\tInteger currentCount = current.get(symbol);\n\n\t\t\t\t\tif (previousCount == null && currentCount == null) { // got a symbol that does not appear in all rows? Discard it.\n\t\t\t\t\t\ttoRemove.add(symbol);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (previousCount == null || currentCount == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tincrement(sums, symbol, Math.abs(previousCount - currentCount)); // we expect to always get 0 or close to 0 here, so the symbol occurs in all rows\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsums.keySet().removeAll(toRemove);\n\n\t\tif (allowedDelimiters.length > 0) {\n\t\t\tSet<Character> toRetain = new HashSet<Character>();\n\t\t\tfor (char c : allowedDelimiters) {\n\t\t\t\ttoRetain.add(c);\n\t\t\t}\n\t\t\tsums.keySet().retainAll(toRetain);\n\t\t}\n\n\t\tchar delimiterMax = max(sums, totals, suggestedDelimiter);\n\t\tchar delimiterMin = min(sums, totals, suggestedDelimiter);\n\n\t\tchar delimiter;\n\t\tout:\n\t\tif (delimiterMax != delimiterMin) {\n\t\t\tif (sums.get(delimiterMin) == 0 && sums.get(delimiterMax) != 0) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\n\t\t\tfor (char c : allowedDelimiters) {\n\t\t\t\tif (c == delimiterMin) {\n\t\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\t\tbreak out;\n\t\t\t\t} else if (c == delimiterMax) {\n\t\t\t\t\tdelimiter = delimiterMax;\n\t\t\t\t\tbreak out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (totals.get(delimiterMin) > totals.get(delimiterMax)) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\t\t\tdelimiter = delimiterMax;\n\t\t} else {\n\t\t\tdelimiter = delimiterMax;\n\t\t}\n\n\t\tchar quote;\n\t\tif(doubleQuoteCount == 0 && singleQuoteCount == 0){\n\t\t\tquote = suggestedQuote;\n\t\t} else {\n\t\t\tquote = doubleQuoteCount >= singleQuoteCount ? '\"' : '\\'';\n\t\t}\n\n\t\tescape.remove(delimiter);\n\t\tchar quoteEscape = doubleQuoteCount == 0 && singleQuoteCount == 0 ? suggestedQuoteEscape : max(escape, totals, quote);\n\t\tapply(delimiter, quote, quoteEscape);\n\t}\n",
        "start_line": 207,
        "end_line": 207,
        "bug_id": "55",
        "before": "\t@Override\n\tpublic void execute(char[] characters, int length) {\n\n\t\tSet<Character> allSymbols = new HashSet<Character>();\n\t\tMap<Character, Integer> symbols = new HashMap<Character, Integer>();\n\t\tMap<Character, Integer> escape = new HashMap<Character, Integer>();\n\t\tList<Map<Character, Integer>> symbolsPerRow = new ArrayList<Map<Character, Integer>>();\n\n\t\tint doubleQuoteCount = 0;\n\t\tint singleQuoteCount = 0;\n\n\t\tint i;\n\t\tchar inQuote = '\\0';\n\t\tboolean afterNewLine = true;\n\t\tfor (i = 0; i < length; i++) {\n\n\t\t\tchar ch = characters[i];\n\n\t\t\tif (afterNewLine && ch == comment) {\n\t\t\t\twhile (++i < length) {\n\t\t\t\t\tch = characters[i];\n\t\t\t\t\tif (ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) {\n\t\t\t\t\t\tif (ch == '\\r' && i + 1 < characters.length && characters[i + 1] == '\\n') {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ch == '\"' || ch == '\\'') {\n\t\t\t\tif (inQuote == ch) { //closing quotes (potentially)\n\t\t\t\t\tif (ch == '\"') {\n\t\t\t\t\t\tdoubleQuoteCount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsingleQuoteCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i + 1 < length) {\n\t\t\t\t\t\tchar next = characters[i + 1];\n\t\t\t\t\t\tif (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\\n' && next != '\\r')) { //no special characters after quote, might be escaping\n\t\t\t\t\t\t\t//special character before (potentially) closing quote, might be an escape\n\t\t\t\t\t\t\tchar prev = characters[i - 1];\n\t\t\t\t\t\t\tif (!Character.isLetterOrDigit(prev) && prev != '\\n' && prev != '\\r') {\n\t\t\t\t\t\t\t\tincrement(escape, prev);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tinQuote = '\\0';\n\t\t\t\t} else if (inQuote == '\\0') {\n\t\t\t\t\tchar prev = '\\0';\n\t\t\t\t\tint j = i;\n\t\t\t\t\twhile (prev <= ' ' && --j >= 0) {\n\t\t\t\t\t\tprev = characters[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j < 0 || !Character.isLetterOrDigit(prev)) {\n\t\t\t\t\t\tinQuote = ch;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inQuote != '\\0') { //keep looping until the quote is closed.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tafterNewLine = false;\n\n\t\t\tif (isSymbol(ch)) { //counts all symbols. Skips letters and digits\n\t\t\t\tallSymbols.add(ch);\n\t\t\t\tincrement(symbols, ch);\n\t\t\t} else if ((ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) && symbols.size() > 0) { //got a newline and collected some symbols? Good!\n\t\t\t\tafterNewLine = true;\n\t\t\t\tsymbolsPerRow.add(symbols);\n\t\t\t\tif (symbolsPerRow.size() == MAX_ROW_SAMPLES) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsymbols = new HashMap<Character, Integer>();\n\t\t\t}\n\t\t}\n\n\t\tif (symbols.size() > 0 && length < characters.length) {\n\t\t\tsymbolsPerRow.add(symbols);\n\t\t}\n\n\t\tif (length >= characters.length && i >= length && symbolsPerRow.size() > 1) { // if got to the end of the buffer, discard last row. It's probably incomplete anyway.\n\t\t\tsymbolsPerRow.remove(symbolsPerRow.size() - 1);\n\t\t}\n\n\t\tMap<Character, Integer> totals = calculateTotals(symbolsPerRow);\n\n\t\tMap<Character, Integer> sums = new HashMap<Character, Integer>();\n\t\tSet<Character> toRemove = new HashSet<Character>();\n\n\t\t//combines the number of symbols found in each row and sums the difference.\n\t\tfor (Map<Character, Integer> previous : symbolsPerRow) {\n\t\t\tfor (Map<Character, Integer> current : symbolsPerRow) {\n\t\t\t\tfor (Character symbol : allSymbols) {\n\t\t\t\t\tInteger previousCount = previous.get(symbol);\n\t\t\t\t\tInteger currentCount = current.get(symbol);\n\n\t\t\t\t\tif (previousCount == null && currentCount == null) { // got a symbol that does not appear in all rows? Discard it.\n\t\t\t\t\t\ttoRemove.add(symbol);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (previousCount == null || currentCount == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tincrement(sums, symbol, Math.abs(previousCount - currentCount)); // we expect to always get 0 or close to 0 here, so the symbol occurs in all rows\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n",
        "after": "\t\tsums.keySet().removeAll(toRemove);\n\n\t\tif (allowedDelimiters.length > 0) {\n\t\t\tSet<Character> toRetain = new HashSet<Character>();\n\t\t\tfor (char c : allowedDelimiters) {\n\t\t\t\ttoRetain.add(c);\n\t\t\t}\n\t\t\tsums.keySet().retainAll(toRetain);\n\t\t}\n\n\t\tchar delimiterMax = max(sums, totals, suggestedDelimiter);\n\t\tchar delimiterMin = min(sums, totals, suggestedDelimiter);\n\n\t\tchar delimiter;\n\t\tout:\n\t\tif (delimiterMax != delimiterMin) {\n\t\t\tif (sums.get(delimiterMin) == 0 && sums.get(delimiterMax) != 0) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\n\t\t\tfor (char c : allowedDelimiters) {\n\t\t\t\tif (c == delimiterMin) {\n\t\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\t\tbreak out;\n\t\t\t\t} else if (c == delimiterMax) {\n\t\t\t\t\tdelimiter = delimiterMax;\n\t\t\t\t\tbreak out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (totals.get(delimiterMin) > totals.get(delimiterMax)) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\t\t\tdelimiter = delimiterMax;\n\t\t} else {\n\t\t\tdelimiter = delimiterMax;\n\t\t}\n\n\t\tchar quote;\n\t\tif(doubleQuoteCount == 0 && singleQuoteCount == 0){\n\t\t\tquote = suggestedQuote;\n\t\t} else {\n\t\t\tquote = doubleQuoteCount >= singleQuoteCount ? '\"' : '\\'';\n\t\t}\n\n\t\tescape.remove(delimiter);\n\t\tchar quoteEscape = doubleQuoteCount == 0 && singleQuoteCount == 0 ? suggestedQuoteEscape : max(escape, totals, quote);\n\t\tapply(delimiter, quote, quoteEscape);\n\t}\n",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 91,
        "method_end_line": 258
    },
    "56_src/main/java/com/xebialabs/overthere/util/WindowsCommandLineArgsSanitizer.java": {
        "context": "    public static boolean containsAnySpecialChars(String str) {\n        if (str.indexOf(PERCENT_CHAR) >= 0) {\n            return true;\n        }\n        for (char c : SPECIAL_CHARS) {\n            if (str.indexOf(c) >= 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n",
        "start_line": 71,
        "end_line": 74,
        "bug_id": "56",
        "before": "    public static boolean containsAnySpecialChars(String str) {\n",
        "after": "        for (char c : SPECIAL_CHARS) {\n            if (str.indexOf(c) >= 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n",
        "buggy_line": "if (str.indexOf(PERCENT_CHAR) >= 0) {            return true;        }",
        "buggy_lines": "        if (str.indexOf(PERCENT_CHAR) >= 0) {\n            return true;\n        }\n",
        "method_start_line": 70,
        "method_end_line": 81
    },
    "63_src/main/java/com/cronutils/parser/CronParser.java": {
        "context": "    private void buildPossibleExpressions(final CronDefinition cronDefinition) {\n        final List<CronParserField> sortedExpression = cronDefinition.getFieldDefinitions().stream()\n                .map(this::toCronParserField)\n                .sorted(CronParserField.createFieldTypeComparator())\n                .collect(Collectors.toList());\n\n        if (lastFieldIsOptional(sortedExpression)) {\n            expressions.put(sortedExpression.size() - 1, new ArrayList<>(sortedExpression.subList(0, sortedExpression.size() - 1)));\n        }\n        expressions.put(sortedExpression.size(), sortedExpression);\n    }\n",
        "start_line": 61,
        "end_line": 63,
        "bug_id": "63",
        "before": "    private void buildPossibleExpressions(final CronDefinition cronDefinition) {\n        final List<CronParserField> sortedExpression = cronDefinition.getFieldDefinitions().stream()\n                .map(this::toCronParserField)\n                .sorted(CronParserField.createFieldTypeComparator())\n                .collect(Collectors.toList());\n\n",
        "after": "        }\n        expressions.put(sortedExpression.size(), sortedExpression);\n    }\n",
        "buggy_line": "if (lastFieldIsOptional(sortedExpression)) {            expressions.put(sortedExpression.size() - 1, new ArrayList<>(sortedExpression.subList(0, sortedExpression.size() - 1)));",
        "buggy_lines": "        if (lastFieldIsOptional(sortedExpression)) {\n            expressions.put(sortedExpression.size() - 1, new ArrayList<>(sortedExpression.subList(0, sortedExpression.size() - 1)));\n",
        "method_start_line": 55,
        "method_end_line": 66
    },
    "65_src/main/java/org/jsoup/internal/Normalizer.java": {
        "context": "    public static String lowerCase(final String input) {\n        return input.toLowerCase(Locale.ENGLISH);\n    }\n",
        "start_line": 11,
        "end_line": 12,
        "bug_id": "65",
        "before": "    public static String lowerCase(final String input) {\n",
        "after": "    }\n",
        "buggy_line": "return input.toLowerCase(Locale.ENGLISH);",
        "buggy_lines": "        return input.toLowerCase(Locale.ENGLISH);\n",
        "method_start_line": 10,
        "method_end_line": 13
    },
    "66_src/main/java/org/jsoup/parser/CharacterReader.java": {
        "context": "    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n",
        "start_line": 427,
        "end_line": 427,
        "bug_id": "66",
        "before": "    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n",
        "after": "\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 423,
        "method_end_line": 452
    },
    "72_src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java": {
        "context": "    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public final Object parseObject(final Map object, Object fieldName) {\n        final JSONLexer lexer = this.lexer;\n\n        if (lexer.token() == JSONToken.NULL) {\n            lexer.nextToken();\n            return null;\n        }\n\n        if (lexer.token() == JSONToken.RBRACE) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() == JSONToken.LITERAL_STRING && lexer.stringVal().length() == 0) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() != JSONToken.LBRACE && lexer.token() != JSONToken.COMMA) {\n            throw new JSONException(\"syntax error, expect {, actual \" + lexer.tokenName() + \", \" + lexer.info());\n        }\n\n       ParseContext context = this.context;\n        try {\n            Map map = object instanceof JSONObject ? ((JSONObject) object).getInnerMap() : object;\n\n            boolean setContextFlag = false;\n            for (;;) {\n                lexer.skipWhitespace();\n                char ch = lexer.getCurrent();\n                if (lexer.isEnabled(Feature.AllowArbitraryCommas)) {\n                    while (ch == ',') {\n                        lexer.next();\n                        lexer.skipWhitespace();\n                        ch = lexer.getCurrent();\n                    }\n                }\n\n                boolean isObjectKey = false;\n                Object key;\n                if (ch == '\"') {\n                    key = lexer.scanSymbol(symbolTable, '\"');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", name \" + key);\n                    }\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    if (!setContextFlag) {\n                        if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                            context = this.context;\n                        } else {\n                            ParseContext contextR = setContext(object, fieldName);\n                            if (context == null) {\n                                context = contextR;\n                            }\n                            setContextFlag = true;\n                        }\n                    }\n\n                    return object;\n                } else if (ch == '\\'') {\n                    if (!lexer.isEnabled(Feature.AllowSingleQuotes)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbol(symbolTable, '\\'');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos());\n                    }\n                } else if (ch == EOI) {\n                    throw new JSONException(\"syntax error\");\n                } else if (ch == ',') {\n                    throw new JSONException(\"syntax error\");\n                } else if ((ch >= '0' && ch <= '9') || ch == '-') {\n                    lexer.resetStringPosition();\n                    lexer.scanNumber();\n                    try {\n                        if (lexer.token() == JSONToken.LITERAL_INT) {\n                            key = lexer.integerValue();\n                        } else {\n                            key = lexer.decimalValue(true);\n                        }\n                        if (lexer.isEnabled(Feature.NonStringKeyAsString)) {\n                            key = key.toString();\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                } else if (ch == '{' || ch == '[') {\n                    lexer.nextToken();\n                    key = parse();\n                    isObjectKey = true;\n                } else {\n                    if (!lexer.isEnabled(Feature.AllowUnQuotedFieldNames)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbolUnQuoted(symbolTable);\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", actual \" + ch);\n                    }\n                }\n\n                if (!isObjectKey) {\n                    lexer.next();\n                    lexer.skipWhitespace();\n                }\n\n                ch = lexer.getCurrent();\n\n                lexer.resetStringPosition();\n\n                if (key == JSON.DEFAULT_TYPE_KEY\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    String typeName = lexer.scanSymbol(symbolTable, '\"');\n\n                    if (lexer.isEnabled(Feature.IgnoreAutoType)) {\n                        continue;\n                    }\n\n                    Class<?> clazz = null;\n                    if (object != null\n                            && object.getClass().getName().equals(typeName)) {\n                        clazz = object.getClass();\n                    } else {\n\n                        boolean allDigits = true;\n                        for (int i = 0; i < typeName.length(); ++i) {\n                            char c = typeName.charAt(i);\n                            if (c < '0' || c > '9') {\n                                allDigits = false;\n                                break;\n                            }\n                        }\n\n                        if (!allDigits) {\n                            clazz = config.checkAutoType(typeName, null, lexer.getFeatures());\n                        }\n                    }\n\n                    if (clazz == null) {\n                        map.put(JSON.DEFAULT_TYPE_KEY, typeName);\n                        continue;\n                    }\n\n                    lexer.nextToken(JSONToken.COMMA);\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken(JSONToken.COMMA);\n                        try {\n                            Object instance = null;\n                            ObjectDeserializer deserializer = this.config.getDeserializer(clazz);\n                            if (deserializer instanceof JavaBeanDeserializer) {\n                            \tinstance = TypeUtils.cast(object, clazz, this.config);\n                            }\n\n                            if (instance == null) {\n                                if (clazz == Cloneable.class) {\n                                    instance = new HashMap();\n                                } else if (\"java.util.Collections$EmptyMap\".equals(typeName)) {\n                                    instance = Collections.emptyMap();\n                                } else if (\"java.util.Collections$UnmodifiableMap\".equals(typeName)) {\n                                    instance = Collections.unmodifiableMap(new HashMap());\n                                } else {\n                                    instance = clazz.newInstance();\n                                }\n                            }\n\n                            return instance;\n                        } catch (Exception e) {\n                            throw new JSONException(\"create instance error\", e);\n                        }\n                    }\n\n                    this.setResolveStatus(TypeNameRedirect);\n\n                    if (this.context != null\n                            && fieldName != null\n                            && !(fieldName instanceof Integer)\n                            && !(this.context.fieldName instanceof Integer)) {\n                        this.popContext();\n                    }\n\n                    if (object.size() > 0) {\n                        Object newObj = TypeUtils.cast(object, clazz, this.config);\n                        this.setResolveStatus(NONE);\n                        this.parseObject(newObj);\n                        return newObj;\n                    }\n\n                    ObjectDeserializer deserializer = config.getDeserializer(clazz);\n                    Class deserClass = deserializer.getClass();\n                    if (JavaBeanDeserializer.class.isAssignableFrom(deserClass)\n                            && deserClass != JavaBeanDeserializer.class\n                            && deserClass != ThrowableDeserializer.class) {\n                        this.setResolveStatus(NONE);\n                    } else if (deserializer instanceof MapDeserializer) {\n                        this.setResolveStatus(NONE);\n                    }\n                    Object obj = deserializer.deserialze(this, clazz, fieldName);\n                    return obj;\n                }\n\n                if (key == \"$ref\"\n                        && context != null\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    lexer.nextToken(JSONToken.LITERAL_STRING);\n                    if (lexer.token() == JSONToken.LITERAL_STRING) {\n                        String ref = lexer.stringVal();\n                        lexer.nextToken(JSONToken.RBRACE);\n\n                        if (lexer.token() == JSONToken.COMMA) {\n                            map.put(key, ref);\n                            continue;\n                        }\n\n                        Object refValue = null;\n                        if (\"@\".equals(ref)) {\n                            if (this.context != null) {\n                                ParseContext thisContext = this.context;\n                                Object thisObj = thisContext.object;\n                                if (thisObj instanceof Object[] || thisObj instanceof Collection<?>) {\n                                    refValue = thisObj;\n                                } else if (thisContext.parent != null) {\n                                    refValue = thisContext.parent.object;\n                                }\n                            }\n                        } else if (\"..\".equals(ref)) {\n                            if (context.object != null) {\n                                refValue = context.object;\n                            } else {\n                                addResolveTask(new ResolveTask(context, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else if (\"$\".equals(ref)) {\n                            ParseContext rootContext = context;\n                            while (rootContext.parent != null) {\n                                rootContext = rootContext.parent;\n                            }\n\n                            if (rootContext.object != null) {\n                                refValue = rootContext.object;\n                            } else {\n                                addResolveTask(new ResolveTask(rootContext, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else {\n                            addResolveTask(new ResolveTask(context, ref));\n                            setResolveStatus(DefaultJSONParser.NeedToResolve);\n                        }\n\n                        if (lexer.token() != JSONToken.RBRACE) {\n                            throw new JSONException(\"syntax error, \" + lexer.info());\n                        }\n                        lexer.nextToken(JSONToken.COMMA);\n\n                        return refValue;\n                    } else {\n                        throw new JSONException(\"illegal ref, \" + JSONToken.name(lexer.token()));\n                    }\n                }\n\n                if (!setContextFlag) {\n                    if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                        context = this.context;\n                    } else {\n                        ParseContext contextR = setContext(object, fieldName);\n                        if (context == null) {\n                            context = contextR;\n                        }\n                        setContextFlag = true;\n                    }\n                }\n\n                if (object.getClass() == JSONObject.class) {\n                    if (key == null) {\n                        key = \"null\";\n                    }\n                }\n\n                Object value;\n                if (ch == '\"') {\n                    lexer.scanString();\n                    String strValue = lexer.stringVal();\n                    value = strValue;\n\n                    if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) {\n                        JSONScanner iso8601Lexer = new JSONScanner(strValue);\n                        if (iso8601Lexer.scanISO8601DateIfMatch()) {\n                            value = iso8601Lexer.getCalendar().getTime();\n                        }\n                        iso8601Lexer.close();\n                    }\n\n                    map.put(key, value);\n                } else if (ch >= '0' && ch <= '9' || ch == '-') {\n                    lexer.scanNumber();\n                    if (lexer.token() == JSONToken.LITERAL_INT) {\n                        value = lexer.integerValue();\n                    } else {\n                        value = lexer.decimalValue(lexer.isEnabled(Feature.UseBigDecimal));\n                    }\n\n                    map.put(key, value);\n                } else if (ch == '[') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9android\n                    lexer.nextToken();\n\n                    JSONArray list = new JSONArray();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n//                    if (!parentIsArray) {\n//                        this.setContext(context);\n//                    }\n                    if (fieldName == null) {\n                        this.setContext(context);\n                    }\n\n                    this.parseArray(list, key);\n\n                    if (lexer.isEnabled(Feature.UseObjectArray)) {\n                        value = list.toArray();\n                    } else {\n                        value = list;\n                    }\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error\");\n                    }\n                } else if (ch == '{') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9 Android\n                    lexer.nextToken();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n\n                    Map input;\n                    if (lexer.isEnabled(Feature.CustomMapDeserializer)) {\n                        MapDeserializer mapDeserializer = (MapDeserializer) config.getDeserializer(Map.class);\n\n\n                        input = (lexer.getFeatures() & Feature.OrderedField.mask) != 0\n                                ? mapDeserializer.createMap(Map.class, lexer.getFeatures())\n                                : mapDeserializer.createMap(Map.class);\n                    } else {\n                        input = new JSONObject(lexer.isEnabled(Feature.OrderedField));\n                    }\n                    ParseContext ctxLocal = null;\n\n                    if (!parentIsArray) {\n                        ctxLocal = setContext(context, input, key);\n                    }\n\n                    Object obj = null;\n                    boolean objParsed = false;\n                    if (fieldTypeResolver != null) {\n                        String resolveFieldName = key != null ? key.toString() : null;\n                        Type fieldType = fieldTypeResolver.resolve(object, resolveFieldName);\n                        if (fieldType != null) {\n                            ObjectDeserializer fieldDeser = config.getDeserializer(fieldType);\n                            obj = fieldDeser.deserialze(this, fieldType, key);\n                            objParsed = true;\n                        }\n                    }\n                    if (!objParsed) {\n                        obj = this.parseObject(input, key);\n                    }\n\n                    if (ctxLocal != null && input != obj) {\n                        ctxLocal.object = object;\n                    }\n\n                    if (key != null) {\n                        checkMapResolve(object, key.toString());\n                    }\n\n                    map.put(key, obj);\n\n                    if (parentIsArray) {\n                        //setContext(context, obj, key);\n                        setContext(obj, key);\n                    }\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n\n                        setContext(context);\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        if (parentIsArray) {\n                            this.popContext();\n                        } else {\n                            this.setContext(context);\n                        }\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, \" + lexer.tokenName());\n                    }\n                } else {\n                    lexer.nextToken();\n                    value = parse();\n\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                    }\n                }\n\n                lexer.skipWhitespace();\n                ch = lexer.getCurrent();\n                if (ch == ',') {\n                    lexer.next();\n                    continue;\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    // this.setContext(object, fieldName);\n                    this.setContext(value, key);\n\n                    return object;\n                } else {\n                    throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                }\n\n            }\n        } finally {\n            this.setContext(context);\n        }\n\n    }\n",
        "start_line": 267,
        "end_line": 268,
        "bug_id": "72",
        "before": "    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public final Object parseObject(final Map object, Object fieldName) {\n        final JSONLexer lexer = this.lexer;\n\n        if (lexer.token() == JSONToken.NULL) {\n            lexer.nextToken();\n            return null;\n        }\n\n        if (lexer.token() == JSONToken.RBRACE) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() == JSONToken.LITERAL_STRING && lexer.stringVal().length() == 0) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() != JSONToken.LBRACE && lexer.token() != JSONToken.COMMA) {\n            throw new JSONException(\"syntax error, expect {, actual \" + lexer.tokenName() + \", \" + lexer.info());\n        }\n\n       ParseContext context = this.context;\n        try {\n            Map map = object instanceof JSONObject ? ((JSONObject) object).getInnerMap() : object;\n\n            boolean setContextFlag = false;\n            for (;;) {\n                lexer.skipWhitespace();\n                char ch = lexer.getCurrent();\n                if (lexer.isEnabled(Feature.AllowArbitraryCommas)) {\n                    while (ch == ',') {\n                        lexer.next();\n                        lexer.skipWhitespace();\n                        ch = lexer.getCurrent();\n                    }\n                }\n\n                boolean isObjectKey = false;\n                Object key;\n                if (ch == '\"') {\n                    key = lexer.scanSymbol(symbolTable, '\"');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", name \" + key);\n                    }\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    if (!setContextFlag) {\n                        if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                            context = this.context;\n                        } else {\n                            ParseContext contextR = setContext(object, fieldName);\n                            if (context == null) {\n                                context = contextR;\n                            }\n                            setContextFlag = true;\n                        }\n                    }\n\n                    return object;\n                } else if (ch == '\\'') {\n                    if (!lexer.isEnabled(Feature.AllowSingleQuotes)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbol(symbolTable, '\\'');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos());\n                    }\n                } else if (ch == EOI) {\n                    throw new JSONException(\"syntax error\");\n                } else if (ch == ',') {\n                    throw new JSONException(\"syntax error\");\n                } else if ((ch >= '0' && ch <= '9') || ch == '-') {\n                    lexer.resetStringPosition();\n                    lexer.scanNumber();\n                    try {\n                        if (lexer.token() == JSONToken.LITERAL_INT) {\n                            key = lexer.integerValue();\n                        } else {\n                            key = lexer.decimalValue(true);\n                        }\n",
        "after": "                            key = key.toString();\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                } else if (ch == '{' || ch == '[') {\n                    lexer.nextToken();\n                    key = parse();\n                    isObjectKey = true;\n                } else {\n                    if (!lexer.isEnabled(Feature.AllowUnQuotedFieldNames)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbolUnQuoted(symbolTable);\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", actual \" + ch);\n                    }\n                }\n\n                if (!isObjectKey) {\n                    lexer.next();\n                    lexer.skipWhitespace();\n                }\n\n                ch = lexer.getCurrent();\n\n                lexer.resetStringPosition();\n\n                if (key == JSON.DEFAULT_TYPE_KEY\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    String typeName = lexer.scanSymbol(symbolTable, '\"');\n\n                    if (lexer.isEnabled(Feature.IgnoreAutoType)) {\n                        continue;\n                    }\n\n                    Class<?> clazz = null;\n                    if (object != null\n                            && object.getClass().getName().equals(typeName)) {\n                        clazz = object.getClass();\n                    } else {\n\n                        boolean allDigits = true;\n                        for (int i = 0; i < typeName.length(); ++i) {\n                            char c = typeName.charAt(i);\n                            if (c < '0' || c > '9') {\n                                allDigits = false;\n                                break;\n                            }\n                        }\n\n                        if (!allDigits) {\n                            clazz = config.checkAutoType(typeName, null, lexer.getFeatures());\n                        }\n                    }\n\n                    if (clazz == null) {\n                        map.put(JSON.DEFAULT_TYPE_KEY, typeName);\n                        continue;\n                    }\n\n                    lexer.nextToken(JSONToken.COMMA);\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken(JSONToken.COMMA);\n                        try {\n                            Object instance = null;\n                            ObjectDeserializer deserializer = this.config.getDeserializer(clazz);\n                            if (deserializer instanceof JavaBeanDeserializer) {\n                            \tinstance = TypeUtils.cast(object, clazz, this.config);\n                            }\n\n                            if (instance == null) {\n                                if (clazz == Cloneable.class) {\n                                    instance = new HashMap();\n                                } else if (\"java.util.Collections$EmptyMap\".equals(typeName)) {\n                                    instance = Collections.emptyMap();\n                                } else if (\"java.util.Collections$UnmodifiableMap\".equals(typeName)) {\n                                    instance = Collections.unmodifiableMap(new HashMap());\n                                } else {\n                                    instance = clazz.newInstance();\n                                }\n                            }\n\n                            return instance;\n                        } catch (Exception e) {\n                            throw new JSONException(\"create instance error\", e);\n                        }\n                    }\n\n                    this.setResolveStatus(TypeNameRedirect);\n\n                    if (this.context != null\n                            && fieldName != null\n                            && !(fieldName instanceof Integer)\n                            && !(this.context.fieldName instanceof Integer)) {\n                        this.popContext();\n                    }\n\n                    if (object.size() > 0) {\n                        Object newObj = TypeUtils.cast(object, clazz, this.config);\n                        this.setResolveStatus(NONE);\n                        this.parseObject(newObj);\n                        return newObj;\n                    }\n\n                    ObjectDeserializer deserializer = config.getDeserializer(clazz);\n                    Class deserClass = deserializer.getClass();\n                    if (JavaBeanDeserializer.class.isAssignableFrom(deserClass)\n                            && deserClass != JavaBeanDeserializer.class\n                            && deserClass != ThrowableDeserializer.class) {\n                        this.setResolveStatus(NONE);\n                    } else if (deserializer instanceof MapDeserializer) {\n                        this.setResolveStatus(NONE);\n                    }\n                    Object obj = deserializer.deserialze(this, clazz, fieldName);\n                    return obj;\n                }\n\n                if (key == \"$ref\"\n                        && context != null\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    lexer.nextToken(JSONToken.LITERAL_STRING);\n                    if (lexer.token() == JSONToken.LITERAL_STRING) {\n                        String ref = lexer.stringVal();\n                        lexer.nextToken(JSONToken.RBRACE);\n\n                        if (lexer.token() == JSONToken.COMMA) {\n                            map.put(key, ref);\n                            continue;\n                        }\n\n                        Object refValue = null;\n                        if (\"@\".equals(ref)) {\n                            if (this.context != null) {\n                                ParseContext thisContext = this.context;\n                                Object thisObj = thisContext.object;\n                                if (thisObj instanceof Object[] || thisObj instanceof Collection<?>) {\n                                    refValue = thisObj;\n                                } else if (thisContext.parent != null) {\n                                    refValue = thisContext.parent.object;\n                                }\n                            }\n                        } else if (\"..\".equals(ref)) {\n                            if (context.object != null) {\n                                refValue = context.object;\n                            } else {\n                                addResolveTask(new ResolveTask(context, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else if (\"$\".equals(ref)) {\n                            ParseContext rootContext = context;\n                            while (rootContext.parent != null) {\n                                rootContext = rootContext.parent;\n                            }\n\n                            if (rootContext.object != null) {\n                                refValue = rootContext.object;\n                            } else {\n                                addResolveTask(new ResolveTask(rootContext, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else {\n                            addResolveTask(new ResolveTask(context, ref));\n                            setResolveStatus(DefaultJSONParser.NeedToResolve);\n                        }\n\n                        if (lexer.token() != JSONToken.RBRACE) {\n                            throw new JSONException(\"syntax error, \" + lexer.info());\n                        }\n                        lexer.nextToken(JSONToken.COMMA);\n\n                        return refValue;\n                    } else {\n                        throw new JSONException(\"illegal ref, \" + JSONToken.name(lexer.token()));\n                    }\n                }\n\n                if (!setContextFlag) {\n                    if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                        context = this.context;\n                    } else {\n                        ParseContext contextR = setContext(object, fieldName);\n                        if (context == null) {\n                            context = contextR;\n                        }\n                        setContextFlag = true;\n                    }\n                }\n\n                if (object.getClass() == JSONObject.class) {\n                    if (key == null) {\n                        key = \"null\";\n                    }\n                }\n\n                Object value;\n                if (ch == '\"') {\n                    lexer.scanString();\n                    String strValue = lexer.stringVal();\n                    value = strValue;\n\n                    if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) {\n                        JSONScanner iso8601Lexer = new JSONScanner(strValue);\n                        if (iso8601Lexer.scanISO8601DateIfMatch()) {\n                            value = iso8601Lexer.getCalendar().getTime();\n                        }\n                        iso8601Lexer.close();\n                    }\n\n                    map.put(key, value);\n                } else if (ch >= '0' && ch <= '9' || ch == '-') {\n                    lexer.scanNumber();\n                    if (lexer.token() == JSONToken.LITERAL_INT) {\n                        value = lexer.integerValue();\n                    } else {\n                        value = lexer.decimalValue(lexer.isEnabled(Feature.UseBigDecimal));\n                    }\n\n                    map.put(key, value);\n                } else if (ch == '[') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9android\n                    lexer.nextToken();\n\n                    JSONArray list = new JSONArray();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n//                    if (!parentIsArray) {\n//                        this.setContext(context);\n//                    }\n                    if (fieldName == null) {\n                        this.setContext(context);\n                    }\n\n                    this.parseArray(list, key);\n\n                    if (lexer.isEnabled(Feature.UseObjectArray)) {\n                        value = list.toArray();\n                    } else {\n                        value = list;\n                    }\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error\");\n                    }\n                } else if (ch == '{') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9 Android\n                    lexer.nextToken();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n\n                    Map input;\n                    if (lexer.isEnabled(Feature.CustomMapDeserializer)) {\n                        MapDeserializer mapDeserializer = (MapDeserializer) config.getDeserializer(Map.class);\n\n\n                        input = (lexer.getFeatures() & Feature.OrderedField.mask) != 0\n                                ? mapDeserializer.createMap(Map.class, lexer.getFeatures())\n                                : mapDeserializer.createMap(Map.class);\n                    } else {\n                        input = new JSONObject(lexer.isEnabled(Feature.OrderedField));\n                    }\n                    ParseContext ctxLocal = null;\n\n                    if (!parentIsArray) {\n                        ctxLocal = setContext(context, input, key);\n                    }\n\n                    Object obj = null;\n                    boolean objParsed = false;\n                    if (fieldTypeResolver != null) {\n                        String resolveFieldName = key != null ? key.toString() : null;\n                        Type fieldType = fieldTypeResolver.resolve(object, resolveFieldName);\n                        if (fieldType != null) {\n                            ObjectDeserializer fieldDeser = config.getDeserializer(fieldType);\n                            obj = fieldDeser.deserialze(this, fieldType, key);\n                            objParsed = true;\n                        }\n                    }\n                    if (!objParsed) {\n                        obj = this.parseObject(input, key);\n                    }\n\n                    if (ctxLocal != null && input != obj) {\n                        ctxLocal.object = object;\n                    }\n\n                    if (key != null) {\n                        checkMapResolve(object, key.toString());\n                    }\n\n                    map.put(key, obj);\n\n                    if (parentIsArray) {\n                        //setContext(context, obj, key);\n                        setContext(obj, key);\n                    }\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n\n                        setContext(context);\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        if (parentIsArray) {\n                            this.popContext();\n                        } else {\n                            this.setContext(context);\n                        }\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, \" + lexer.tokenName());\n                    }\n                } else {\n                    lexer.nextToken();\n                    value = parse();\n\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                    }\n                }\n\n                lexer.skipWhitespace();\n                ch = lexer.getCurrent();\n                if (ch == ',') {\n                    lexer.next();\n                    continue;\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    // this.setContext(object, fieldName);\n                    this.setContext(value, key);\n\n                    return object;\n                } else {\n                    throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                }\n\n            }\n        } finally {\n            this.setContext(context);\n        }\n\n    }\n",
        "buggy_line": "if (lexer.isEnabled(Feature.NonStringKeyAsString)) {",
        "buggy_lines": "                        if (lexer.isEnabled(Feature.NonStringKeyAsString)) {\n",
        "method_start_line": 177,
        "method_end_line": 631
    },
    "73_src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java": {
        "context": "    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public final Object parseObject(final Map object, Object fieldName) {\n        final JSONLexer lexer = this.lexer;\n\n        if (lexer.token() == JSONToken.NULL) {\n            lexer.nextToken();\n            return null;\n        }\n\n        if (lexer.token() == JSONToken.RBRACE) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() == JSONToken.LITERAL_STRING && lexer.stringVal().length() == 0) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() != JSONToken.LBRACE && lexer.token() != JSONToken.COMMA) {\n            throw new JSONException(\"syntax error, expect {, actual \" + lexer.tokenName() + \", \" + lexer.info());\n        }\n\n       ParseContext context = this.context;\n        try {\n            boolean isJsonObjectMap = object instanceof JSONObject;\n            Map map = isJsonObjectMap ? ((JSONObject) object).getInnerMap() : object;\n\n            boolean setContextFlag = false;\n            for (;;) {\n                lexer.skipWhitespace();\n                char ch = lexer.getCurrent();\n                if (lexer.isEnabled(Feature.AllowArbitraryCommas)) {\n                    while (ch == ',') {\n                        lexer.next();\n                        lexer.skipWhitespace();\n                        ch = lexer.getCurrent();\n                    }\n                }\n\n                boolean isObjectKey = false;\n                Object key;\n                if (ch == '\"') {\n                    key = lexer.scanSymbol(symbolTable, '\"');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", name \" + key);\n                    }\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    if (!setContextFlag) {\n                        if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                            context = this.context;\n                        } else {\n                            ParseContext contextR = setContext(object, fieldName);\n                            if (context == null) {\n                                context = contextR;\n                            }\n                            setContextFlag = true;\n                        }\n                    }\n\n                    return object;\n                } else if (ch == '\\'') {\n                    if (!lexer.isEnabled(Feature.AllowSingleQuotes)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbol(symbolTable, '\\'');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos());\n                    }\n                } else if (ch == EOI) {\n                    throw new JSONException(\"syntax error\");\n                } else if (ch == ',') {\n                    throw new JSONException(\"syntax error\");\n                } else if ((ch >= '0' && ch <= '9') || ch == '-') {\n                    lexer.resetStringPosition();\n                    lexer.scanNumber();\n                    try {\n                        if (lexer.token() == JSONToken.LITERAL_INT) {\n                            key = lexer.integerValue();\n                        } else {\n                            key = lexer.decimalValue(true);\n                        }\n                        if (lexer.isEnabled(Feature.NonStringKeyAsString) || isJsonObjectMap) {\n                            key = key.toString();\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                } else if (ch == '{' || ch == '[') {\n                    if (objectKeyLevel++ > 512) {\n                        throw new JSONException(\"object key level > 512\");\n                    }\n                    lexer.nextToken();\n                    key = parse();\n                    isObjectKey = true;\n                } else {\n                    if (!lexer.isEnabled(Feature.AllowUnQuotedFieldNames)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbolUnQuoted(symbolTable);\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", actual \" + ch);\n                    }\n                }\n\n                if (!isObjectKey) {\n                    lexer.next();\n                    lexer.skipWhitespace();\n                }\n\n                ch = lexer.getCurrent();\n\n                lexer.resetStringPosition();\n\n                if (key == JSON.DEFAULT_TYPE_KEY\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    String typeName = lexer.scanSymbol(symbolTable, '\"');\n\n                    if (lexer.isEnabled(Feature.IgnoreAutoType)) {\n                        continue;\n                    }\n\n                    Class<?> clazz = null;\n                    if (object != null\n                            && object.getClass().getName().equals(typeName)) {\n                        clazz = object.getClass();\n                    } else {\n\n                        boolean allDigits = true;\n                        for (int i = 0; i < typeName.length(); ++i) {\n                            char c = typeName.charAt(i);\n                            if (c < '0' || c > '9') {\n                                allDigits = false;\n                                break;\n                            }\n                        }\n\n                        if (!allDigits) {\n                            clazz = config.checkAutoType(typeName, null, lexer.getFeatures());\n                        }\n                    }\n\n                    if (clazz == null) {\n                        map.put(JSON.DEFAULT_TYPE_KEY, typeName);\n                        continue;\n                    }\n\n                    lexer.nextToken(JSONToken.COMMA);\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken(JSONToken.COMMA);\n                        try {\n                            Object instance = null;\n                            ObjectDeserializer deserializer = this.config.getDeserializer(clazz);\n                            if (deserializer instanceof JavaBeanDeserializer) {\n                            \tinstance = TypeUtils.cast(object, clazz, this.config);\n                            }\n\n                            if (instance == null) {\n                                if (clazz == Cloneable.class) {\n                                    instance = new HashMap();\n                                } else if (\"java.util.Collections$EmptyMap\".equals(typeName)) {\n                                    instance = Collections.emptyMap();\n                                } else if (\"java.util.Collections$UnmodifiableMap\".equals(typeName)) {\n                                    instance = Collections.unmodifiableMap(new HashMap());\n                                } else {\n                                    instance = clazz.newInstance();\n                                }\n                            }\n\n                            return instance;\n                        } catch (Exception e) {\n                            throw new JSONException(\"create instance error\", e);\n                        }\n                    }\n\n                    this.setResolveStatus(TypeNameRedirect);\n\n                    if (this.context != null\n                            && fieldName != null\n                            && !(fieldName instanceof Integer)\n                            && !(this.context.fieldName instanceof Integer)) {\n                        this.popContext();\n                    }\n\n                    if (object.size() > 0) {\n                        Object newObj = TypeUtils.cast(object, clazz, this.config);\n                        this.setResolveStatus(NONE);\n                        this.parseObject(newObj);\n                        return newObj;\n                    }\n\n                    ObjectDeserializer deserializer = config.getDeserializer(clazz);\n                    Class deserClass = deserializer.getClass();\n                    if (JavaBeanDeserializer.class.isAssignableFrom(deserClass)\n                            && deserClass != JavaBeanDeserializer.class\n                            && deserClass != ThrowableDeserializer.class) {\n                        this.setResolveStatus(NONE);\n                    } else if (deserializer instanceof MapDeserializer) {\n                        this.setResolveStatus(NONE);\n                    }\n                    Object obj = deserializer.deserialze(this, clazz, fieldName);\n                    return obj;\n                }\n\n                if (key == \"$ref\"\n                        && context != null\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    lexer.nextToken(JSONToken.LITERAL_STRING);\n                    if (lexer.token() == JSONToken.LITERAL_STRING) {\n                        String ref = lexer.stringVal();\n                        lexer.nextToken(JSONToken.RBRACE);\n\n                        if (lexer.token() == JSONToken.COMMA) {\n                            map.put(key, ref);\n                            continue;\n                        }\n\n                        Object refValue = null;\n                        if (\"@\".equals(ref)) {\n                            if (this.context != null) {\n                                ParseContext thisContext = this.context;\n                                Object thisObj = thisContext.object;\n                                if (thisObj instanceof Object[] || thisObj instanceof Collection<?>) {\n                                    refValue = thisObj;\n                                } else if (thisContext.parent != null) {\n                                    refValue = thisContext.parent.object;\n                                }\n                            }\n                        } else if (\"..\".equals(ref)) {\n                            if (context.object != null) {\n                                refValue = context.object;\n                            } else {\n                                addResolveTask(new ResolveTask(context, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else if (\"$\".equals(ref)) {\n                            ParseContext rootContext = context;\n                            while (rootContext.parent != null) {\n                                rootContext = rootContext.parent;\n                            }\n\n                            if (rootContext.object != null) {\n                                refValue = rootContext.object;\n                            } else {\n                                addResolveTask(new ResolveTask(rootContext, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else {\n                            addResolveTask(new ResolveTask(context, ref));\n                            setResolveStatus(DefaultJSONParser.NeedToResolve);\n                        }\n\n                        if (lexer.token() != JSONToken.RBRACE) {\n                            throw new JSONException(\"syntax error, \" + lexer.info());\n                        }\n                        lexer.nextToken(JSONToken.COMMA);\n\n                        return refValue;\n                    } else {\n                        throw new JSONException(\"illegal ref, \" + JSONToken.name(lexer.token()));\n                    }\n                }\n\n                if (!setContextFlag) {\n                    if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                        context = this.context;\n                    } else {\n                        ParseContext contextR = setContext(object, fieldName);\n                        if (context == null) {\n                            context = contextR;\n                        }\n                        setContextFlag = true;\n                    }\n                }\n\n                if (object.getClass() == JSONObject.class) {\n                    if (key == null) {\n                        key = \"null\";\n                    }\n                }\n\n                Object value;\n                if (ch == '\"') {\n                    lexer.scanString();\n                    String strValue = lexer.stringVal();\n                    value = strValue;\n\n                    if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) {\n                        JSONScanner iso8601Lexer = new JSONScanner(strValue);\n                        if (iso8601Lexer.scanISO8601DateIfMatch()) {\n                            value = iso8601Lexer.getCalendar().getTime();\n                        }\n                        iso8601Lexer.close();\n                    }\n\n                    map.put(key, value);\n                } else if (ch >= '0' && ch <= '9' || ch == '-') {\n                    lexer.scanNumber();\n                    if (lexer.token() == JSONToken.LITERAL_INT) {\n                        value = lexer.integerValue();\n                    } else {\n                        value = lexer.decimalValue(lexer.isEnabled(Feature.UseBigDecimal));\n                    }\n\n                    map.put(key, value);\n                } else if (ch == '[') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9android\n                    lexer.nextToken();\n\n                    JSONArray list = new JSONArray();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n//                    if (!parentIsArray) {\n//                        this.setContext(context);\n//                    }\n                    if (fieldName == null) {\n                        this.setContext(context);\n                    }\n\n                    this.parseArray(list, key);\n\n                    if (lexer.isEnabled(Feature.UseObjectArray)) {\n                        value = list.toArray();\n                    } else {\n                        value = list;\n                    }\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error\");\n                    }\n                } else if (ch == '{') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9 Android\n                    lexer.nextToken();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n\n                    Map input;\n                    if (lexer.isEnabled(Feature.CustomMapDeserializer)) {\n                        MapDeserializer mapDeserializer = (MapDeserializer) config.getDeserializer(Map.class);\n\n\n                        input = (lexer.getFeatures() & Feature.OrderedField.mask) != 0\n                                ? mapDeserializer.createMap(Map.class, lexer.getFeatures())\n                                : mapDeserializer.createMap(Map.class);\n                    } else {\n                        input = new JSONObject(lexer.isEnabled(Feature.OrderedField));\n                    }\n                    ParseContext ctxLocal = null;\n\n                    if (!parentIsArray) {\n                        ctxLocal = setContext(context, input, key);\n                    }\n\n                    Object obj = null;\n                    boolean objParsed = false;\n                    if (fieldTypeResolver != null) {\n                        String resolveFieldName = key != null ? key.toString() : null;\n                        Type fieldType = fieldTypeResolver.resolve(object, resolveFieldName);\n                        if (fieldType != null) {\n                            ObjectDeserializer fieldDeser = config.getDeserializer(fieldType);\n                            obj = fieldDeser.deserialze(this, fieldType, key);\n                            objParsed = true;\n                        }\n                    }\n                    if (!objParsed) {\n                        obj = this.parseObject(input, key);\n                    }\n\n                    if (ctxLocal != null && input != obj) {\n                        ctxLocal.object = object;\n                    }\n\n                    if (key != null) {\n                        checkMapResolve(object, key.toString());\n                    }\n\n                    map.put(key, obj);\n\n                    if (parentIsArray) {\n                        //setContext(context, obj, key);\n                        setContext(obj, key);\n                    }\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n\n                        setContext(context);\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        if (parentIsArray) {\n                            this.popContext();\n                        } else {\n                            this.setContext(context);\n                        }\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, \" + lexer.tokenName());\n                    }\n                } else {\n                    lexer.nextToken();\n                    value = parse();\n\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                    }\n                }\n\n                lexer.skipWhitespace();\n                ch = lexer.getCurrent();\n                if (ch == ',') {\n                    lexer.next();\n                    continue;\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    // this.setContext(object, fieldName);\n                    this.setContext(value, key);\n\n                    return object;\n                } else {\n                    throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                }\n\n            }\n        } finally {\n            this.setContext(context);\n        }\n\n    }\n",
        "start_line": 401,
        "end_line": 401,
        "bug_id": "73",
        "before": "    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public final Object parseObject(final Map object, Object fieldName) {\n        final JSONLexer lexer = this.lexer;\n\n        if (lexer.token() == JSONToken.NULL) {\n            lexer.nextToken();\n            return null;\n        }\n\n        if (lexer.token() == JSONToken.RBRACE) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() == JSONToken.LITERAL_STRING && lexer.stringVal().length() == 0) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() != JSONToken.LBRACE && lexer.token() != JSONToken.COMMA) {\n            throw new JSONException(\"syntax error, expect {, actual \" + lexer.tokenName() + \", \" + lexer.info());\n        }\n\n       ParseContext context = this.context;\n        try {\n            boolean isJsonObjectMap = object instanceof JSONObject;\n            Map map = isJsonObjectMap ? ((JSONObject) object).getInnerMap() : object;\n\n            boolean setContextFlag = false;\n            for (;;) {\n                lexer.skipWhitespace();\n                char ch = lexer.getCurrent();\n                if (lexer.isEnabled(Feature.AllowArbitraryCommas)) {\n                    while (ch == ',') {\n                        lexer.next();\n                        lexer.skipWhitespace();\n                        ch = lexer.getCurrent();\n                    }\n                }\n\n                boolean isObjectKey = false;\n                Object key;\n                if (ch == '\"') {\n                    key = lexer.scanSymbol(symbolTable, '\"');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", name \" + key);\n                    }\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    if (!setContextFlag) {\n                        if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                            context = this.context;\n                        } else {\n                            ParseContext contextR = setContext(object, fieldName);\n                            if (context == null) {\n                                context = contextR;\n                            }\n                            setContextFlag = true;\n                        }\n                    }\n\n                    return object;\n                } else if (ch == '\\'') {\n                    if (!lexer.isEnabled(Feature.AllowSingleQuotes)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbol(symbolTable, '\\'');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos());\n                    }\n                } else if (ch == EOI) {\n                    throw new JSONException(\"syntax error\");\n                } else if (ch == ',') {\n                    throw new JSONException(\"syntax error\");\n                } else if ((ch >= '0' && ch <= '9') || ch == '-') {\n                    lexer.resetStringPosition();\n                    lexer.scanNumber();\n                    try {\n                        if (lexer.token() == JSONToken.LITERAL_INT) {\n                            key = lexer.integerValue();\n                        } else {\n                            key = lexer.decimalValue(true);\n                        }\n                        if (lexer.isEnabled(Feature.NonStringKeyAsString) || isJsonObjectMap) {\n                            key = key.toString();\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                } else if (ch == '{' || ch == '[') {\n                    if (objectKeyLevel++ > 512) {\n                        throw new JSONException(\"object key level > 512\");\n                    }\n                    lexer.nextToken();\n                    key = parse();\n                    isObjectKey = true;\n                } else {\n                    if (!lexer.isEnabled(Feature.AllowUnQuotedFieldNames)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbolUnQuoted(symbolTable);\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", actual \" + ch);\n                    }\n                }\n\n                if (!isObjectKey) {\n                    lexer.next();\n                    lexer.skipWhitespace();\n                }\n\n                ch = lexer.getCurrent();\n\n                lexer.resetStringPosition();\n\n                if (key == JSON.DEFAULT_TYPE_KEY\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    String typeName = lexer.scanSymbol(symbolTable, '\"');\n\n                    if (lexer.isEnabled(Feature.IgnoreAutoType)) {\n                        continue;\n                    }\n\n                    Class<?> clazz = null;\n                    if (object != null\n                            && object.getClass().getName().equals(typeName)) {\n                        clazz = object.getClass();\n                    } else {\n\n                        boolean allDigits = true;\n                        for (int i = 0; i < typeName.length(); ++i) {\n                            char c = typeName.charAt(i);\n                            if (c < '0' || c > '9') {\n                                allDigits = false;\n                                break;\n                            }\n                        }\n\n                        if (!allDigits) {\n                            clazz = config.checkAutoType(typeName, null, lexer.getFeatures());\n                        }\n                    }\n\n                    if (clazz == null) {\n                        map.put(JSON.DEFAULT_TYPE_KEY, typeName);\n                        continue;\n                    }\n\n                    lexer.nextToken(JSONToken.COMMA);\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken(JSONToken.COMMA);\n                        try {\n                            Object instance = null;\n                            ObjectDeserializer deserializer = this.config.getDeserializer(clazz);\n                            if (deserializer instanceof JavaBeanDeserializer) {\n                            \tinstance = TypeUtils.cast(object, clazz, this.config);\n                            }\n\n                            if (instance == null) {\n                                if (clazz == Cloneable.class) {\n                                    instance = new HashMap();\n                                } else if (\"java.util.Collections$EmptyMap\".equals(typeName)) {\n                                    instance = Collections.emptyMap();\n                                } else if (\"java.util.Collections$UnmodifiableMap\".equals(typeName)) {\n                                    instance = Collections.unmodifiableMap(new HashMap());\n                                } else {\n                                    instance = clazz.newInstance();\n                                }\n                            }\n\n                            return instance;\n                        } catch (Exception e) {\n                            throw new JSONException(\"create instance error\", e);\n                        }\n                    }\n\n                    this.setResolveStatus(TypeNameRedirect);\n\n                    if (this.context != null\n                            && fieldName != null\n                            && !(fieldName instanceof Integer)\n                            && !(this.context.fieldName instanceof Integer)) {\n                        this.popContext();\n                    }\n\n                    if (object.size() > 0) {\n                        Object newObj = TypeUtils.cast(object, clazz, this.config);\n                        this.setResolveStatus(NONE);\n                        this.parseObject(newObj);\n                        return newObj;\n                    }\n\n                    ObjectDeserializer deserializer = config.getDeserializer(clazz);\n                    Class deserClass = deserializer.getClass();\n                    if (JavaBeanDeserializer.class.isAssignableFrom(deserClass)\n                            && deserClass != JavaBeanDeserializer.class\n                            && deserClass != ThrowableDeserializer.class) {\n                        this.setResolveStatus(NONE);\n                    } else if (deserializer instanceof MapDeserializer) {\n                        this.setResolveStatus(NONE);\n                    }\n                    Object obj = deserializer.deserialze(this, clazz, fieldName);\n                    return obj;\n                }\n\n                if (key == \"$ref\"\n                        && context != null\n",
        "after": "                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    lexer.nextToken(JSONToken.LITERAL_STRING);\n                    if (lexer.token() == JSONToken.LITERAL_STRING) {\n                        String ref = lexer.stringVal();\n                        lexer.nextToken(JSONToken.RBRACE);\n\n                        if (lexer.token() == JSONToken.COMMA) {\n                            map.put(key, ref);\n                            continue;\n                        }\n\n                        Object refValue = null;\n                        if (\"@\".equals(ref)) {\n                            if (this.context != null) {\n                                ParseContext thisContext = this.context;\n                                Object thisObj = thisContext.object;\n                                if (thisObj instanceof Object[] || thisObj instanceof Collection<?>) {\n                                    refValue = thisObj;\n                                } else if (thisContext.parent != null) {\n                                    refValue = thisContext.parent.object;\n                                }\n                            }\n                        } else if (\"..\".equals(ref)) {\n                            if (context.object != null) {\n                                refValue = context.object;\n                            } else {\n                                addResolveTask(new ResolveTask(context, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else if (\"$\".equals(ref)) {\n                            ParseContext rootContext = context;\n                            while (rootContext.parent != null) {\n                                rootContext = rootContext.parent;\n                            }\n\n                            if (rootContext.object != null) {\n                                refValue = rootContext.object;\n                            } else {\n                                addResolveTask(new ResolveTask(rootContext, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else {\n                            addResolveTask(new ResolveTask(context, ref));\n                            setResolveStatus(DefaultJSONParser.NeedToResolve);\n                        }\n\n                        if (lexer.token() != JSONToken.RBRACE) {\n                            throw new JSONException(\"syntax error, \" + lexer.info());\n                        }\n                        lexer.nextToken(JSONToken.COMMA);\n\n                        return refValue;\n                    } else {\n                        throw new JSONException(\"illegal ref, \" + JSONToken.name(lexer.token()));\n                    }\n                }\n\n                if (!setContextFlag) {\n                    if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                        context = this.context;\n                    } else {\n                        ParseContext contextR = setContext(object, fieldName);\n                        if (context == null) {\n                            context = contextR;\n                        }\n                        setContextFlag = true;\n                    }\n                }\n\n                if (object.getClass() == JSONObject.class) {\n                    if (key == null) {\n                        key = \"null\";\n                    }\n                }\n\n                Object value;\n                if (ch == '\"') {\n                    lexer.scanString();\n                    String strValue = lexer.stringVal();\n                    value = strValue;\n\n                    if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) {\n                        JSONScanner iso8601Lexer = new JSONScanner(strValue);\n                        if (iso8601Lexer.scanISO8601DateIfMatch()) {\n                            value = iso8601Lexer.getCalendar().getTime();\n                        }\n                        iso8601Lexer.close();\n                    }\n\n                    map.put(key, value);\n                } else if (ch >= '0' && ch <= '9' || ch == '-') {\n                    lexer.scanNumber();\n                    if (lexer.token() == JSONToken.LITERAL_INT) {\n                        value = lexer.integerValue();\n                    } else {\n                        value = lexer.decimalValue(lexer.isEnabled(Feature.UseBigDecimal));\n                    }\n\n                    map.put(key, value);\n                } else if (ch == '[') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9android\n                    lexer.nextToken();\n\n                    JSONArray list = new JSONArray();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n//                    if (!parentIsArray) {\n//                        this.setContext(context);\n//                    }\n                    if (fieldName == null) {\n                        this.setContext(context);\n                    }\n\n                    this.parseArray(list, key);\n\n                    if (lexer.isEnabled(Feature.UseObjectArray)) {\n                        value = list.toArray();\n                    } else {\n                        value = list;\n                    }\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error\");\n                    }\n                } else if (ch == '{') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9 Android\n                    lexer.nextToken();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n\n                    Map input;\n                    if (lexer.isEnabled(Feature.CustomMapDeserializer)) {\n                        MapDeserializer mapDeserializer = (MapDeserializer) config.getDeserializer(Map.class);\n\n\n                        input = (lexer.getFeatures() & Feature.OrderedField.mask) != 0\n                                ? mapDeserializer.createMap(Map.class, lexer.getFeatures())\n                                : mapDeserializer.createMap(Map.class);\n                    } else {\n                        input = new JSONObject(lexer.isEnabled(Feature.OrderedField));\n                    }\n                    ParseContext ctxLocal = null;\n\n                    if (!parentIsArray) {\n                        ctxLocal = setContext(context, input, key);\n                    }\n\n                    Object obj = null;\n                    boolean objParsed = false;\n                    if (fieldTypeResolver != null) {\n                        String resolveFieldName = key != null ? key.toString() : null;\n                        Type fieldType = fieldTypeResolver.resolve(object, resolveFieldName);\n                        if (fieldType != null) {\n                            ObjectDeserializer fieldDeser = config.getDeserializer(fieldType);\n                            obj = fieldDeser.deserialze(this, fieldType, key);\n                            objParsed = true;\n                        }\n                    }\n                    if (!objParsed) {\n                        obj = this.parseObject(input, key);\n                    }\n\n                    if (ctxLocal != null && input != obj) {\n                        ctxLocal.object = object;\n                    }\n\n                    if (key != null) {\n                        checkMapResolve(object, key.toString());\n                    }\n\n                    map.put(key, obj);\n\n                    if (parentIsArray) {\n                        //setContext(context, obj, key);\n                        setContext(obj, key);\n                    }\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n\n                        setContext(context);\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        if (parentIsArray) {\n                            this.popContext();\n                        } else {\n                            this.setContext(context);\n                        }\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, \" + lexer.tokenName());\n                    }\n                } else {\n                    lexer.nextToken();\n                    value = parse();\n\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                    }\n                }\n\n                lexer.skipWhitespace();\n                ch = lexer.getCurrent();\n                if (ch == ',') {\n                    lexer.next();\n                    continue;\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    // this.setContext(object, fieldName);\n                    this.setContext(value, key);\n\n                    return object;\n                } else {\n                    throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                }\n\n            }\n        } finally {\n            this.setContext(context);\n        }\n\n    }\n",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 179,
        "method_end_line": 637
    },
    "74_src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java": {
        "context": "    public String scanString(char expectNextChar) {\n        matchStat = UNKNOWN;\n\n        int offset = 0;\n        char chLocal = charAt(bp + (offset++));\n\n        if (chLocal == 'n') {\n            if (charAt(bp + offset) == 'u' && charAt(bp + offset + 1) == 'l' && charAt(bp + offset + 2) == 'l') {\n                offset += 3;\n                chLocal = charAt(bp + (offset++));\n            } else {\n                matchStat = NOT_MATCH;\n                return null;\n            }\n\n            if (chLocal == expectNextChar) {\n                bp += offset;\n                this.ch = this.charAt(bp);\n                matchStat = VALUE;\n                return null;\n            } else {\n                matchStat = NOT_MATCH;\n                return null;\n            }\n        }\n\n        final String strVal;\n        for (;;) {\n            if (chLocal == '\"') {\n                int startIndex = bp + offset;\n                int endIndex = indexOf('\"', startIndex);\n                if (endIndex == -1) {\n                    throw new JSONException(\"unclosed str\");\n                }\n\n                String stringVal = subString(bp + offset, endIndex - startIndex);\n                if (stringVal.indexOf('\\\\') != -1) {\n                    for (; ; ) {\n                        int slashCount = 0;\n                        for (int i = endIndex - 1; i >= 0; --i) {\n                            if (charAt(i) == '\\\\') {\n                                slashCount++;\n                            } else {\n                                break;\n                            }\n                        }\n                        if (slashCount % 2 == 0) {\n                            break;\n                        }\n                        endIndex = indexOf('\"', endIndex + 1);\n                    }\n\n                    int chars_len = endIndex - startIndex;\n                    char[] chars = sub_chars(bp + 1, chars_len);\n\n                    stringVal = readString(chars, chars_len);\n                }\n\n                offset += (endIndex - startIndex + 1);\n                chLocal = charAt(bp + (offset++));\n                strVal = stringVal;\n                break;\n            } else if (isWhitespace(chLocal)) {\n                chLocal = charAt(bp + (offset++));\n                continue;\n            } else {\n                matchStat = NOT_MATCH;\n\n                return stringDefaultValue();\n            }\n        }\n\n        for (;;) {\n            if (chLocal == expectNextChar) {\n                bp += offset;\n                this.ch = charAt(bp);\n                matchStat = VALUE;\n                token = JSONToken.COMMA;\n                return strVal;\n            } else if (isWhitespace(chLocal)) {\n                chLocal = charAt(bp + (offset++));\n                continue;\n            } else {\n                matchStat = NOT_MATCH;\n                return strVal;\n            }\n        }\n    }\n",
        "start_line": 1416,
        "end_line": 1417,
        "bug_id": "74",
        "before": "    public String scanString(char expectNextChar) {\n        matchStat = UNKNOWN;\n\n        int offset = 0;\n        char chLocal = charAt(bp + (offset++));\n\n        if (chLocal == 'n') {\n            if (charAt(bp + offset) == 'u' && charAt(bp + offset + 1) == 'l' && charAt(bp + offset + 2) == 'l') {\n                offset += 3;\n                chLocal = charAt(bp + (offset++));\n            } else {\n                matchStat = NOT_MATCH;\n                return null;\n            }\n\n            if (chLocal == expectNextChar) {\n                bp += offset;\n                this.ch = this.charAt(bp);\n                matchStat = VALUE;\n                return null;\n            } else {\n                matchStat = NOT_MATCH;\n                return null;\n            }\n        }\n\n        final String strVal;\n        for (;;) {\n            if (chLocal == '\"') {\n                int startIndex = bp + offset;\n                int endIndex = indexOf('\"', startIndex);\n                if (endIndex == -1) {\n                    throw new JSONException(\"unclosed str\");\n                }\n\n                String stringVal = subString(bp + offset, endIndex - startIndex);\n                if (stringVal.indexOf('\\\\') != -1) {\n                    for (; ; ) {\n                        int slashCount = 0;\n                        for (int i = endIndex - 1; i >= 0; --i) {\n                            if (charAt(i) == '\\\\') {\n                                slashCount++;\n                            } else {\n                                break;\n                            }\n                        }\n                        if (slashCount % 2 == 0) {\n                            break;\n                        }\n                        endIndex = indexOf('\"', endIndex + 1);\n                    }\n\n                    int chars_len = endIndex - startIndex;\n                    char[] chars = sub_chars(bp + 1, chars_len);\n\n                    stringVal = readString(chars, chars_len);\n                }\n\n                offset += (endIndex - startIndex + 1);\n                chLocal = charAt(bp + (offset++));\n                strVal = stringVal;\n                break;\n            } else if (isWhitespace(chLocal)) {\n                chLocal = charAt(bp + (offset++));\n                continue;\n            } else {\n                matchStat = NOT_MATCH;\n\n                return stringDefaultValue();\n            }\n        }\n\n        for (;;) {\n            if (chLocal == expectNextChar) {\n                bp += offset;\n                this.ch = charAt(bp);\n                matchStat = VALUE;\n                token = JSONToken.COMMA;\n                return strVal;\n            } else if (isWhitespace(chLocal)) {\n                chLocal = charAt(bp + (offset++));\n                continue;\n            } else {\n",
        "after": "                return strVal;\n            }\n        }\n    }\n",
        "buggy_line": "matchStat = NOT_MATCH;",
        "buggy_lines": "                matchStat = NOT_MATCH;\n",
        "method_start_line": 1333,
        "method_end_line": 1421
    },
    "75_src/main/java/com/alibaba/fastjson/util/FieldInfo.java": {
        "context": "    public static Type getFieldType(final Class<?> clazz, final Type type, Type fieldType) {\n        if (clazz == null || type == null) {\n            return fieldType;\n        }\n\n        if (fieldType instanceof GenericArrayType) {\n            GenericArrayType genericArrayType = (GenericArrayType) fieldType;\n            Type componentType = genericArrayType.getGenericComponentType();\n            Type componentTypeX = getFieldType(clazz, type, componentType);\n            if (componentType != componentTypeX) {\n                Type fieldTypeX = Array.newInstance(TypeUtils.getClass(componentTypeX), 0).getClass();\n                return fieldTypeX;\n            }\n\n            return fieldType;\n        }\n\n        if (!TypeUtils.isGenericParamType(type)) {\n            return fieldType;\n        }\n\n        if (fieldType instanceof TypeVariable) {\n            ParameterizedType paramType = (ParameterizedType) TypeUtils.getGenericParamType(type);\n            Class<?> parameterizedClass = TypeUtils.getClass(paramType);\n            final TypeVariable<?> typeVar = (TypeVariable<?>) fieldType;\n            \n            TypeVariable<?>[] typeVariables = parameterizedClass.getTypeParameters();\n            for (int i = 0; i < typeVariables.length; ++i) {\n                if (typeVariables[i].getName().equals(typeVar.getName())) {\n                    fieldType = paramType.getActualTypeArguments()[i];\n                    return fieldType;\n                }\n            }\n        }\n\n        if (fieldType instanceof ParameterizedType) {\n            ParameterizedType parameterizedFieldType = (ParameterizedType) fieldType;\n\n            Type[] arguments = parameterizedFieldType.getActualTypeArguments();\n            TypeVariable<?>[] typeVariables = null;\n            ParameterizedType paramType = null;\n            if (type instanceof ParameterizedType) {\n                paramType = (ParameterizedType) type;\n                typeVariables = clazz.getTypeParameters();\n            } else if(clazz.getGenericSuperclass() instanceof ParameterizedType) {\n                paramType = (ParameterizedType) clazz.getGenericSuperclass();\n                typeVariables = clazz.getSuperclass().getTypeParameters();\n            }\n\n            boolean changed = getArgument(arguments, typeVariables, paramType.getActualTypeArguments());\n            if (changed) {\n                fieldType = new ParameterizedTypeImpl(arguments, parameterizedFieldType.getOwnerType(),\n                                                      parameterizedFieldType.getRawType());\n                return fieldType;\n            }\n        }\n\n        return fieldType;\n    }\n",
        "start_line": 292,
        "end_line": 294,
        "bug_id": "75",
        "before": "    public static Type getFieldType(final Class<?> clazz, final Type type, Type fieldType) {\n        if (clazz == null || type == null) {\n            return fieldType;\n        }\n\n        if (fieldType instanceof GenericArrayType) {\n            GenericArrayType genericArrayType = (GenericArrayType) fieldType;\n            Type componentType = genericArrayType.getGenericComponentType();\n            Type componentTypeX = getFieldType(clazz, type, componentType);\n            if (componentType != componentTypeX) {\n                Type fieldTypeX = Array.newInstance(TypeUtils.getClass(componentTypeX), 0).getClass();\n                return fieldTypeX;\n            }\n\n            return fieldType;\n        }\n\n        if (!TypeUtils.isGenericParamType(type)) {\n            return fieldType;\n        }\n\n        if (fieldType instanceof TypeVariable) {\n            ParameterizedType paramType = (ParameterizedType) TypeUtils.getGenericParamType(type);\n            Class<?> parameterizedClass = TypeUtils.getClass(paramType);\n            final TypeVariable<?> typeVar = (TypeVariable<?>) fieldType;\n            \n            TypeVariable<?>[] typeVariables = parameterizedClass.getTypeParameters();\n            for (int i = 0; i < typeVariables.length; ++i) {\n                if (typeVariables[i].getName().equals(typeVar.getName())) {\n                    fieldType = paramType.getActualTypeArguments()[i];\n                    return fieldType;\n                }\n            }\n        }\n\n        if (fieldType instanceof ParameterizedType) {\n            ParameterizedType parameterizedFieldType = (ParameterizedType) fieldType;\n\n            Type[] arguments = parameterizedFieldType.getActualTypeArguments();\n",
        "after": "            if (type instanceof ParameterizedType) {\n                paramType = (ParameterizedType) type;\n                typeVariables = clazz.getTypeParameters();\n            } else if(clazz.getGenericSuperclass() instanceof ParameterizedType) {\n                paramType = (ParameterizedType) clazz.getGenericSuperclass();\n                typeVariables = clazz.getSuperclass().getTypeParameters();\n            }\n\n            boolean changed = getArgument(arguments, typeVariables, paramType.getActualTypeArguments());\n            if (changed) {\n                fieldType = new ParameterizedTypeImpl(arguments, parameterizedFieldType.getOwnerType(),\n                                                      parameterizedFieldType.getRawType());\n                return fieldType;\n            }\n        }\n\n        return fieldType;\n    }\n",
        "buggy_line": "TypeVariable<?>[] typeVariables = null;            ParameterizedType paramType = null;",
        "buggy_lines": "            TypeVariable<?>[] typeVariables = null;\n            ParameterizedType paramType = null;\n",
        "method_start_line": 253,
        "method_end_line": 312
    },
    "76_src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java": {
        "context": "    private static CronDefinition quartz() {\n        return CronDefinitionBuilder.defineCron()\n                .withSeconds().withStrictRange().and()\n                .withMinutes().withStrictRange().and()\n                .withHours().withStrictRange().and()\n                .withDayOfMonth().withValidRange(1, 32).supportsL().supportsW().supportsLW().supportsQuestionMark().withStrictRange().and()\n                .withMonth().withValidRange(1, 13).and()\n                .withDayOfWeek().withValidRange(1, 7).withMondayDoWValue(2).supportsHash().supportsL().supportsQuestionMark().and()\n                .withYear().withValidRange(1970, 2099).withStrictRange().optional().and()\n                .withCronValidation(CronConstraintsFactory.ensureEitherDayOfWeekOrDayOfMonth())\n                .instance();\n    }\n",
        "start_line": 261,
        "end_line": 265,
        "bug_id": "76",
        "before": "    private static CronDefinition quartz() {\n        return CronDefinitionBuilder.defineCron()\n",
        "after": "                .withMonth().withValidRange(1, 13).and()\n                .withDayOfWeek().withValidRange(1, 7).withMondayDoWValue(2).supportsHash().supportsL().supportsQuestionMark().and()\n                .withYear().withValidRange(1970, 2099).withStrictRange().optional().and()\n                .withCronValidation(CronConstraintsFactory.ensureEitherDayOfWeekOrDayOfMonth())\n                .instance();\n    }\n",
        "buggy_line": ".withSeconds().withStrictRange().and()                .withMinutes().withStrictRange().and()                .withHours().withStrictRange().and()                .withDayOfMonth().withValidRange(1, 32).supportsL().supportsW().supportsLW().supportsQuestionMark().withStrictRange().and()",
        "buggy_lines": "                .withSeconds().withStrictRange().and()\n                .withMinutes().withStrictRange().and()\n                .withHours().withStrictRange().and()\n                .withDayOfMonth().withValidRange(1, 32).supportsL().supportsW().supportsLW().supportsQuestionMark().withStrictRange().and()\n",
        "method_start_line": 259,
        "method_end_line": 271
    },
    "77_src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java": {
        "context": "    private static CronDefinition quartz() {\n        return CronDefinitionBuilder.defineCron()\n                .withSeconds().and()\n                .withMinutes().and()\n                .withHours().and()\n                .withDayOfMonth().supportsL().supportsW().supportsLW().supportsQuestionMark().and()\n                .withMonth().and()\n                .withDayOfWeek().withValidRange(1, 7).withMondayDoWValue(2).supportsHash().supportsL().supportsQuestionMark().and()\n                .withYear().withValidRange(1970, 2099).optional().and()\n                .withCronValidation(CronConstraintsFactory.ensureEitherDayOfWeekOrDayOfMonth())\n                .instance();\n    }\n",
        "start_line": 276,
        "end_line": 278,
        "bug_id": "77",
        "before": "    private static CronDefinition quartz() {\n        return CronDefinitionBuilder.defineCron()\n                .withSeconds().and()\n                .withMinutes().and()\n                .withHours().and()\n",
        "after": "                .withDayOfWeek().withValidRange(1, 7).withMondayDoWValue(2).supportsHash().supportsL().supportsQuestionMark().and()\n                .withYear().withValidRange(1970, 2099).optional().and()\n                .withCronValidation(CronConstraintsFactory.ensureEitherDayOfWeekOrDayOfMonth())\n                .instance();\n    }\n",
        "buggy_line": ".withDayOfMonth().supportsL().supportsW().supportsLW().supportsQuestionMark().and()                .withMonth().and()",
        "buggy_lines": "                .withDayOfMonth().supportsL().supportsW().supportsLW().supportsQuestionMark().and()\n                .withMonth().and()\n",
        "method_start_line": 271,
        "method_end_line": 283
    },
    "81_java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java": {
        "context": "  public RenderOnlySoyMsgBundleImpl(@Nullable String localeString, Iterable<SoyMsg> msgs) {\n\n    this.localeString = localeString;\n    this.locale = localeString == null ? null : new ULocale(localeString);\n    this.isRtl = BidiGlobalDir.forStaticLocale(localeString) == BidiGlobalDir.RTL;\n\n    // This creates the mask. Basically, take the high-bit and fill in the bits below it.\n    int maskHigh = Integer.highestOneBit(Iterables.size(msgs));\n    this.bucketMask = (maskHigh | (maskHigh - 1)) >>> BUCKET_SHIFT;\n    int numBuckets = this.bucketMask + 1;\n\n    // Sorts by bucket (low bits within the mask) and breaks ties with the full ID.\n    Comparator<SoyMsg> bucketComparator =\n        Comparator.comparingInt((SoyMsg m) -> bucketOf(m.getId())).thenComparingLong(SoyMsg::getId);\n    ImmutableList<SoyMsg> sortedMsgs = ImmutableList.sortedCopyOf(bucketComparator, msgs);\n\n    // Scan the sorted list to discover bucket boundaries and place them into the boundaries array.\n    bucketBoundaries = new int[numBuckets + 1];\n    for (int bucket = 0, idx = 0; bucket < numBuckets; bucket++) {\n      bucketBoundaries[bucket] = idx;\n      for (;\n          (idx < sortedMsgs.size()) && (bucketOf(sortedMsgs.get(idx).getId()) == bucket);\n          idx++) {}\n    }\n    bucketBoundaries[numBuckets] = sortedMsgs.size();\n\n    ids = new long[sortedMsgs.size()];\n    ImmutableList.Builder<SoyMsgPart> partsBuilder = ImmutableList.builder();\n    partRanges = new int[sortedMsgs.size() + 1];\n    partRanges[0] = 0; // The first range always starts at the beginning of the list.\n    long priorId = sortedMsgs.isEmpty() ? -1L : sortedMsgs.get(0).getId() - 1L;\n    int runningPartCount = 0;\n    for (int i = 0, c = sortedMsgs.size(); i < c; i++) {\n      SoyMsg msg = sortedMsgs.get(i);\n      ImmutableList<SoyMsgPart> parts = msg.getParts();\n\n      checkArgument(\n          msg.getId() != priorId, \"Duplicate messages are not permitted in the render-only impl.\");\n      checkArgument(\n          MsgPartUtils.hasPlrselPart(parts) == msg.isPlrselMsg(),\n          \"Message's plural/select status is inconsistent -- internal compiler bug.\");\n\n      priorId = msg.getId();\n      ids[i] = msg.getId();\n      partsBuilder.addAll(parts);\n      runningPartCount += parts.size();\n      partRanges[i + 1] = runningPartCount; // runningPartCount is the end of range, hence +1\n    }\n\n    // This will build the collections in the same order as the sorted map.\n    values = partsBuilder.build();\n  }\n",
        "start_line": 145,
        "end_line": 146,
        "bug_id": "81",
        "before": "  public RenderOnlySoyMsgBundleImpl(@Nullable String localeString, Iterable<SoyMsg> msgs) {\n\n    this.localeString = localeString;\n    this.locale = localeString == null ? null : new ULocale(localeString);\n    this.isRtl = BidiGlobalDir.forStaticLocale(localeString) == BidiGlobalDir.RTL;\n\n    // This creates the mask. Basically, take the high-bit and fill in the bits below it.\n    int maskHigh = Integer.highestOneBit(Iterables.size(msgs));\n",
        "after": "    int numBuckets = this.bucketMask + 1;\n\n    // Sorts by bucket (low bits within the mask) and breaks ties with the full ID.\n    Comparator<SoyMsg> bucketComparator =\n        Comparator.comparingInt((SoyMsg m) -> bucketOf(m.getId())).thenComparingLong(SoyMsg::getId);\n    ImmutableList<SoyMsg> sortedMsgs = ImmutableList.sortedCopyOf(bucketComparator, msgs);\n\n    // Scan the sorted list to discover bucket boundaries and place them into the boundaries array.\n    bucketBoundaries = new int[numBuckets + 1];\n    for (int bucket = 0, idx = 0; bucket < numBuckets; bucket++) {\n      bucketBoundaries[bucket] = idx;\n      for (;\n          (idx < sortedMsgs.size()) && (bucketOf(sortedMsgs.get(idx).getId()) == bucket);\n          idx++) {}\n    }\n    bucketBoundaries[numBuckets] = sortedMsgs.size();\n\n    ids = new long[sortedMsgs.size()];\n    ImmutableList.Builder<SoyMsgPart> partsBuilder = ImmutableList.builder();\n    partRanges = new int[sortedMsgs.size() + 1];\n    partRanges[0] = 0; // The first range always starts at the beginning of the list.\n    long priorId = sortedMsgs.isEmpty() ? -1L : sortedMsgs.get(0).getId() - 1L;\n    int runningPartCount = 0;\n    for (int i = 0, c = sortedMsgs.size(); i < c; i++) {\n      SoyMsg msg = sortedMsgs.get(i);\n      ImmutableList<SoyMsgPart> parts = msg.getParts();\n\n      checkArgument(\n          msg.getId() != priorId, \"Duplicate messages are not permitted in the render-only impl.\");\n      checkArgument(\n          MsgPartUtils.hasPlrselPart(parts) == msg.isPlrselMsg(),\n          \"Message's plural/select status is inconsistent -- internal compiler bug.\");\n\n      priorId = msg.getId();\n      ids[i] = msg.getId();\n      partsBuilder.addAll(parts);\n      runningPartCount += parts.size();\n      partRanges[i + 1] = runningPartCount; // runningPartCount is the end of range, hence +1\n    }\n\n    // This will build the collections in the same order as the sorted map.\n    values = partsBuilder.build();\n  }\n",
        "buggy_line": "this.bucketMask = (maskHigh | (maskHigh - 1)) >>> BUCKET_SHIFT;",
        "buggy_lines": "    this.bucketMask = (maskHigh | (maskHigh - 1)) >>> BUCKET_SHIFT;\n",
        "method_start_line": 137,
        "method_end_line": 189
    },
    "82_java/src/com/google/template/soy/msgs/restricted/RenderOnlySoyMsgBundleImpl.java": {
        "context": "  public RenderOnlySoyMsgBundleImpl(@Nullable String localeString, Iterable<SoyMsg> msgs) {\n\n    this.localeString = localeString;\n    this.locale = localeString == null ? null : new ULocale(localeString);\n    this.isRtl = BidiGlobalDir.forStaticLocale(localeString) == BidiGlobalDir.RTL;\n\n    // This creates the mask. Basically, take the high-bit and fill in the bits below it.\n    int maskHigh = Integer.highestOneBit(Iterables.size(msgs));\n    this.bucketMask = (maskHigh | (maskHigh - 1)) >>> BUCKET_SHIFT;\n    int numBuckets = this.bucketMask + 1;\n\n    // Sorts by bucket (low bits within the mask) and breaks ties with the full ID.\n    Comparator<SoyMsg> bucketComparator =\n        Comparator.comparingInt((SoyMsg m) -> bucketOf(m.getId())).thenComparingLong(SoyMsg::getId);\n    ImmutableList<SoyMsg> sortedMsgs = ImmutableList.sortedCopyOf(bucketComparator, msgs);\n\n    // Scan the sorted list to discover bucket boundaries and place them into the boundaries array.\n    bucketBoundaries = new int[numBuckets + 1];\n    for (int bucket = 0, idx = 0; bucket < numBuckets; bucket++) {\n      bucketBoundaries[bucket] = idx;\n      for (;\n          (idx < sortedMsgs.size()) && (bucketOf(sortedMsgs.get(idx).getId()) == bucket);\n          idx++) {}\n    }\n    bucketBoundaries[numBuckets] = sortedMsgs.size();\n\n    ids = new long[sortedMsgs.size()];\n    ImmutableList.Builder<SoyMsgPart> partsBuilder = ImmutableList.builder();\n    partRanges = new int[sortedMsgs.size() + 1];\n    partRanges[0] = 0; // The first range always starts at the beginning of the list.\n    long priorId = sortedMsgs.isEmpty() ? -1L : sortedMsgs.get(0).getId() - 1L;\n    int runningPartCount = 0;\n    for (int i = 0, c = sortedMsgs.size(); i < c; i++) {\n      SoyMsg msg = sortedMsgs.get(i);\n      ImmutableList<SoyMsgPart> parts = msg.getParts();\n\n      checkArgument(\n          msg.getId() != priorId, \"Duplicate messages are not permitted in the render-only impl.\");\n      checkArgument(\n          MsgPartUtils.hasPlrselPart(parts) == msg.isPlrselMsg(),\n          \"Message's plural/select status is inconsistent -- internal compiler bug.\");\n\n      priorId = msg.getId();\n      ids[i] = msg.getId();\n      partsBuilder.addAll(parts);\n      runningPartCount += parts.size();\n      partRanges[i + 1] = runningPartCount; // runningPartCount is the end of range, hence +1\n    }\n\n    // This will build the collections in the same order as the sorted map.\n    values = partsBuilder.build();\n  }\n",
        "start_line": 146,
        "end_line": 147,
        "bug_id": "82",
        "before": "  public RenderOnlySoyMsgBundleImpl(@Nullable String localeString, Iterable<SoyMsg> msgs) {\n\n    this.localeString = localeString;\n    this.locale = localeString == null ? null : new ULocale(localeString);\n    this.isRtl = BidiGlobalDir.forStaticLocale(localeString) == BidiGlobalDir.RTL;\n\n    // This creates the mask. Basically, take the high-bit and fill in the bits below it.\n    int maskHigh = Integer.highestOneBit(Iterables.size(msgs));\n    this.bucketMask = (maskHigh | (maskHigh - 1)) >>> BUCKET_SHIFT;\n",
        "after": "\n    // Sorts by bucket (low bits within the mask) and breaks ties with the full ID.\n    Comparator<SoyMsg> bucketComparator =\n        Comparator.comparingInt((SoyMsg m) -> bucketOf(m.getId())).thenComparingLong(SoyMsg::getId);\n    ImmutableList<SoyMsg> sortedMsgs = ImmutableList.sortedCopyOf(bucketComparator, msgs);\n\n    // Scan the sorted list to discover bucket boundaries and place them into the boundaries array.\n    bucketBoundaries = new int[numBuckets + 1];\n    for (int bucket = 0, idx = 0; bucket < numBuckets; bucket++) {\n      bucketBoundaries[bucket] = idx;\n      for (;\n          (idx < sortedMsgs.size()) && (bucketOf(sortedMsgs.get(idx).getId()) == bucket);\n          idx++) {}\n    }\n    bucketBoundaries[numBuckets] = sortedMsgs.size();\n\n    ids = new long[sortedMsgs.size()];\n    ImmutableList.Builder<SoyMsgPart> partsBuilder = ImmutableList.builder();\n    partRanges = new int[sortedMsgs.size() + 1];\n    partRanges[0] = 0; // The first range always starts at the beginning of the list.\n    long priorId = sortedMsgs.isEmpty() ? -1L : sortedMsgs.get(0).getId() - 1L;\n    int runningPartCount = 0;\n    for (int i = 0, c = sortedMsgs.size(); i < c; i++) {\n      SoyMsg msg = sortedMsgs.get(i);\n      ImmutableList<SoyMsgPart> parts = msg.getParts();\n\n      checkArgument(\n          msg.getId() != priorId, \"Duplicate messages are not permitted in the render-only impl.\");\n      checkArgument(\n          MsgPartUtils.hasPlrselPart(parts) == msg.isPlrselMsg(),\n          \"Message's plural/select status is inconsistent -- internal compiler bug.\");\n\n      priorId = msg.getId();\n      ids[i] = msg.getId();\n      partsBuilder.addAll(parts);\n      runningPartCount += parts.size();\n      partRanges[i + 1] = runningPartCount; // runningPartCount is the end of range, hence +1\n    }\n\n    // This will build the collections in the same order as the sorted map.\n    values = partsBuilder.build();\n  }\n",
        "buggy_line": "int numBuckets = this.bucketMask + 1;",
        "buggy_lines": "    int numBuckets = this.bucketMask + 1;\n",
        "method_start_line": 137,
        "method_end_line": 189
    },
    "84_java/src/com/google/template/soy/jssrc/dsl/CodeChunkUtils.java": {
        "context": "  public static Expression concatChunksForceString(List<? extends Expression> chunks) {\n    if (!chunks.isEmpty()\n        && chunks.get(0).isRepresentableAsSingleExpression()\n        && JsExprUtils.isStringLiteral(\n            chunks.get(0).assertExprAndCollectRequires(RequiresCollector.NULL))) {\n      return concatChunks(chunks);\n    } else if (chunks.size() > 1\n        && chunks.get(1).isRepresentableAsSingleExpression()\n        && JsExprUtils.isStringLiteral(\n            chunks.get(1).assertExprAndCollectRequires(RequiresCollector.NULL))) {\n      return concatChunks(chunks);\n    } else {\n      return concatChunks(\n          ImmutableList.of(LITERAL_EMPTY_STRING, Group.create(concatChunks(chunks))));\n    }\n  }\n",
        "start_line": 82,
        "end_line": 83,
        "bug_id": "84",
        "before": "  public static Expression concatChunksForceString(List<? extends Expression> chunks) {\n    if (!chunks.isEmpty()\n        && chunks.get(0).isRepresentableAsSingleExpression()\n        && JsExprUtils.isStringLiteral(\n            chunks.get(0).assertExprAndCollectRequires(RequiresCollector.NULL))) {\n      return concatChunks(chunks);\n    } else if (chunks.size() > 1\n        && chunks.get(1).isRepresentableAsSingleExpression()\n        && JsExprUtils.isStringLiteral(\n            chunks.get(1).assertExprAndCollectRequires(RequiresCollector.NULL))) {\n      return concatChunks(chunks);\n    } else {\n      return concatChunks(\n",
        "after": "    }\n  }\n",
        "buggy_line": "ImmutableList.of(LITERAL_EMPTY_STRING, Group.create(concatChunks(chunks))));",
        "buggy_lines": "          ImmutableList.of(LITERAL_EMPTY_STRING, Group.create(concatChunks(chunks))));\n",
        "method_start_line": 69,
        "method_end_line": 85
    },
    "95_src/main/java/com/alibaba/fastjson/serializer/DateCodec.java": {
        "context": "    public void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features) throws IOException {\n        SerializeWriter out = serializer.out;\n\n        if (object == null) {\n            out.writeNull();\n            return;\n        }\n\n        Class<?> clazz = object.getClass();\n        if (clazz == java.sql.Date.class) {\n            long millis = ((java.sql.Date) object).getTime();\n            TimeZone timeZone = serializer.timeZone;\n            int offset = timeZone.getOffset(millis);\n            //\n            if ((millis + offset) % (24 * 1000 * 3600) == 0\n                    && !SerializerFeature.isEnabled(out.features, features, SerializerFeature.WriteClassName)) {\n                out.writeString(object.toString());\n                return;\n            }\n        }\n\n        if (clazz == java.sql.Time.class) {\n            long millis = ((java.sql.Time) object).getTime();\n            if (\"unixtime\".equals(serializer.getDateFormatPattern())) {\n                long seconds = millis / 1000;\n                out.writeLong(seconds);\n                return;\n            }\n\n            if (\"millis\".equals(serializer.getDateFormatPattern())) {\n                long seconds = millis;\n                out.writeLong(millis);\n                return;\n            }\n\n            if (millis < 24L * 60L * 60L * 1000L) {\n                out.writeString(object.toString());\n                return;\n            }\n        }\n\n        int nanos = 0;\n        if (clazz == java.sql.Timestamp.class) {\n            java.sql.Timestamp ts = (java.sql.Timestamp) object;\n            nanos = ts.getNanos();\n        }\n        \n        Date date;\n        if (object instanceof Date) {\n            date = (Date) object;\n        } else {\n            date = TypeUtils.castToDate(object);\n        }\n\n        if (\"unixtime\".equals(serializer.getDateFormatPattern())) {\n            long seconds = date.getTime() / 1000;\n            out.writeLong(seconds);\n            return;\n        }\n\n        if (\"millis\".equals(serializer.getDateFormatPattern())) {\n            long millis = date.getTime();\n            out.writeLong(millis);\n            return;\n        }\n\n        if (out.isEnabled(SerializerFeature.WriteDateUseDateFormat)) {\n            DateFormat format = serializer.getDateFormat();\n            if (format == null) {\n                format = new SimpleDateFormat(JSON.DEFFAULT_DATE_FORMAT, serializer.locale);\n                format.setTimeZone(serializer.timeZone);\n            }\n            String text = format.format(date);\n            out.writeString(text);\n            return;\n        }\n        \n        if (out.isEnabled(SerializerFeature.WriteClassName)) {\n            if (clazz != fieldType) {\n                if (clazz == java.util.Date.class) {\n                    out.write(\"new Date(\");\n                    out.writeLong(((Date) object).getTime());\n                    out.write(')');\n                } else {\n                    out.write('{');\n                    out.writeFieldName(JSON.DEFAULT_TYPE_KEY);\n                    serializer.write(clazz.getName());\n                    out.writeFieldValue(',', \"val\", ((Date) object).getTime());\n                    out.write('}');\n                }\n                return;\n            }\n        }\n\n        long time = date.getTime();\n        if (out.isEnabled(SerializerFeature.UseISO8601DateFormat)) {\n            char quote = out.isEnabled(SerializerFeature.UseSingleQuotes) ? '\\'' : '\\\"'; \n            out.write(quote);\n\n            Calendar calendar = Calendar.getInstance(serializer.timeZone, serializer.locale);\n            calendar.setTimeInMillis(time);\n\n            int year = calendar.get(Calendar.YEAR);\n            int month = calendar.get(Calendar.MONTH) + 1;\n            int day = calendar.get(Calendar.DAY_OF_MONTH);\n            int hour = calendar.get(Calendar.HOUR_OF_DAY);\n            int minute = calendar.get(Calendar.MINUTE);\n            int second = calendar.get(Calendar.SECOND);\n            int millis = calendar.get(Calendar.MILLISECOND);\n\n            char[] buf;\n            if (nanos > 0) {\n                buf = \"0000-00-00 00:00:00.000000000\".toCharArray();\n                int nanoSize = IOUtils.stringSize(nanos);\n                IOUtils.getChars(nanos, 30 - (9 - nanoSize), buf);\n                IOUtils.getChars(second, 19, buf);\n                IOUtils.getChars(minute, 16, buf);\n                IOUtils.getChars(hour, 13, buf);\n                IOUtils.getChars(day, 10, buf);\n                IOUtils.getChars(month, 7, buf);\n                IOUtils.getChars(year, 4, buf);\n            } else if (millis != 0) {\n                buf = \"0000-00-00T00:00:00.000\".toCharArray();\n                IOUtils.getChars(millis, 23, buf);\n                IOUtils.getChars(second, 19, buf);\n                IOUtils.getChars(minute, 16, buf);\n                IOUtils.getChars(hour, 13, buf);\n                IOUtils.getChars(day, 10, buf);\n                IOUtils.getChars(month, 7, buf);\n                IOUtils.getChars(year, 4, buf);\n\n            } else {\n                if (second == 0 && minute == 0 && hour == 0) {\n                    buf = \"0000-00-00\".toCharArray();\n                    IOUtils.getChars(day, 10, buf);\n                    IOUtils.getChars(month, 7, buf);\n                    IOUtils.getChars(year, 4, buf);\n                } else {\n                    buf = \"0000-00-00T00:00:00\".toCharArray();\n                    IOUtils.getChars(second, 19, buf);\n                    IOUtils.getChars(minute, 16, buf);\n                    IOUtils.getChars(hour, 13, buf);\n                    IOUtils.getChars(day, 10, buf);\n                    IOUtils.getChars(month, 7, buf);\n                    IOUtils.getChars(year, 4, buf);\n                }\n            }\n            \n            out.write(buf);\n            if (nanos > 0) { // java.sql.Timestamp\n                out.write(quote);\n                return;\n            }\n\n            float timeZoneF = calendar.getTimeZone().getOffset(calendar.getTimeInMillis()) / (3600.0f * 1000);\n            int timeZone = (int)timeZoneF;\n            if (timeZone == 0.0) {\n                out.write('Z');\n            } else {\n                if (timeZone > 9) {\n                    out.write('+');\n                    out.writeInt(timeZone);\n                } else if (timeZone > 0) {\n                    out.write('+');\n                    out.write('0');\n                    out.writeInt(timeZone);\n                } else if (timeZone < -9) {\n                    out.write('-');\n                    out.writeInt(-timeZone);\n                } else if (timeZone < 0) {\n                    out.write('-');\n                    out.write('0');\n                    out.writeInt(-timeZone);\n                }\n                out.write(':');\n                // handles uneven timeZones 30 mins, 45 mins\n                // this would always be less than 60\n                int offSet = (int)(Math.abs(timeZoneF - timeZone) * 60);\n                out.append(String.format(\"%02d\", offSet));\n            }\n\n            out.write(quote);\n        } else {\n            out.writeLong(time);\n        }\n    }\n",
        "start_line": 159,
        "end_line": 160,
        "bug_id": "95",
        "before": "    public void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features) throws IOException {\n        SerializeWriter out = serializer.out;\n\n        if (object == null) {\n            out.writeNull();\n            return;\n        }\n\n        Class<?> clazz = object.getClass();\n        if (clazz == java.sql.Date.class) {\n            long millis = ((java.sql.Date) object).getTime();\n            TimeZone timeZone = serializer.timeZone;\n            int offset = timeZone.getOffset(millis);\n            //\n            if ((millis + offset) % (24 * 1000 * 3600) == 0\n                    && !SerializerFeature.isEnabled(out.features, features, SerializerFeature.WriteClassName)) {\n                out.writeString(object.toString());\n                return;\n            }\n        }\n\n        if (clazz == java.sql.Time.class) {\n            long millis = ((java.sql.Time) object).getTime();\n            if (\"unixtime\".equals(serializer.getDateFormatPattern())) {\n                long seconds = millis / 1000;\n                out.writeLong(seconds);\n                return;\n            }\n\n            if (\"millis\".equals(serializer.getDateFormatPattern())) {\n                long seconds = millis;\n                out.writeLong(millis);\n                return;\n            }\n\n            if (millis < 24L * 60L * 60L * 1000L) {\n                out.writeString(object.toString());\n                return;\n            }\n        }\n\n        int nanos = 0;\n        if (clazz == java.sql.Timestamp.class) {\n            java.sql.Timestamp ts = (java.sql.Timestamp) object;\n            nanos = ts.getNanos();\n        }\n        \n        Date date;\n        if (object instanceof Date) {\n            date = (Date) object;\n        } else {\n            date = TypeUtils.castToDate(object);\n        }\n\n        if (\"unixtime\".equals(serializer.getDateFormatPattern())) {\n            long seconds = date.getTime() / 1000;\n            out.writeLong(seconds);\n            return;\n        }\n\n        if (\"millis\".equals(serializer.getDateFormatPattern())) {\n            long millis = date.getTime();\n            out.writeLong(millis);\n            return;\n        }\n\n        if (out.isEnabled(SerializerFeature.WriteDateUseDateFormat)) {\n            DateFormat format = serializer.getDateFormat();\n            if (format == null) {\n                format = new SimpleDateFormat(JSON.DEFFAULT_DATE_FORMAT, serializer.locale);\n                format.setTimeZone(serializer.timeZone);\n            }\n            String text = format.format(date);\n            out.writeString(text);\n            return;\n        }\n        \n        if (out.isEnabled(SerializerFeature.WriteClassName)) {\n            if (clazz != fieldType) {\n                if (clazz == java.util.Date.class) {\n                    out.write(\"new Date(\");\n                    out.writeLong(((Date) object).getTime());\n                    out.write(')');\n                } else {\n                    out.write('{');\n                    out.writeFieldName(JSON.DEFAULT_TYPE_KEY);\n                    serializer.write(clazz.getName());\n                    out.writeFieldValue(',', \"val\", ((Date) object).getTime());\n                    out.write('}');\n                }\n                return;\n            }\n        }\n\n        long time = date.getTime();\n        if (out.isEnabled(SerializerFeature.UseISO8601DateFormat)) {\n            char quote = out.isEnabled(SerializerFeature.UseSingleQuotes) ? '\\'' : '\\\"'; \n            out.write(quote);\n\n            Calendar calendar = Calendar.getInstance(serializer.timeZone, serializer.locale);\n            calendar.setTimeInMillis(time);\n\n            int year = calendar.get(Calendar.YEAR);\n            int month = calendar.get(Calendar.MONTH) + 1;\n            int day = calendar.get(Calendar.DAY_OF_MONTH);\n            int hour = calendar.get(Calendar.HOUR_OF_DAY);\n            int minute = calendar.get(Calendar.MINUTE);\n            int second = calendar.get(Calendar.SECOND);\n            int millis = calendar.get(Calendar.MILLISECOND);\n\n            char[] buf;\n            if (nanos > 0) {\n                buf = \"0000-00-00 00:00:00.000000000\".toCharArray();\n                int nanoSize = IOUtils.stringSize(nanos);\n",
        "after": "                IOUtils.getChars(second, 19, buf);\n                IOUtils.getChars(minute, 16, buf);\n                IOUtils.getChars(hour, 13, buf);\n                IOUtils.getChars(day, 10, buf);\n                IOUtils.getChars(month, 7, buf);\n                IOUtils.getChars(year, 4, buf);\n            } else if (millis != 0) {\n                buf = \"0000-00-00T00:00:00.000\".toCharArray();\n                IOUtils.getChars(millis, 23, buf);\n                IOUtils.getChars(second, 19, buf);\n                IOUtils.getChars(minute, 16, buf);\n                IOUtils.getChars(hour, 13, buf);\n                IOUtils.getChars(day, 10, buf);\n                IOUtils.getChars(month, 7, buf);\n                IOUtils.getChars(year, 4, buf);\n\n            } else {\n                if (second == 0 && minute == 0 && hour == 0) {\n                    buf = \"0000-00-00\".toCharArray();\n                    IOUtils.getChars(day, 10, buf);\n                    IOUtils.getChars(month, 7, buf);\n                    IOUtils.getChars(year, 4, buf);\n                } else {\n                    buf = \"0000-00-00T00:00:00\".toCharArray();\n                    IOUtils.getChars(second, 19, buf);\n                    IOUtils.getChars(minute, 16, buf);\n                    IOUtils.getChars(hour, 13, buf);\n                    IOUtils.getChars(day, 10, buf);\n                    IOUtils.getChars(month, 7, buf);\n                    IOUtils.getChars(year, 4, buf);\n                }\n            }\n            \n            out.write(buf);\n            if (nanos > 0) { // java.sql.Timestamp\n                out.write(quote);\n                return;\n            }\n\n            float timeZoneF = calendar.getTimeZone().getOffset(calendar.getTimeInMillis()) / (3600.0f * 1000);\n            int timeZone = (int)timeZoneF;\n            if (timeZone == 0.0) {\n                out.write('Z');\n            } else {\n                if (timeZone > 9) {\n                    out.write('+');\n                    out.writeInt(timeZone);\n                } else if (timeZone > 0) {\n                    out.write('+');\n                    out.write('0');\n                    out.writeInt(timeZone);\n                } else if (timeZone < -9) {\n                    out.write('-');\n                    out.writeInt(-timeZone);\n                } else if (timeZone < 0) {\n                    out.write('-');\n                    out.write('0');\n                    out.writeInt(-timeZone);\n                }\n                out.write(':');\n                // handles uneven timeZones 30 mins, 45 mins\n                // this would always be less than 60\n                int offSet = (int)(Math.abs(timeZoneF - timeZone) * 60);\n                out.append(String.format(\"%02d\", offSet));\n            }\n\n            out.write(quote);\n        } else {\n            out.writeLong(time);\n        }\n    }\n",
        "buggy_line": "IOUtils.getChars(nanos, 30 - (9 - nanoSize), buf);",
        "buggy_lines": "                IOUtils.getChars(nanos, 30 - (9 - nanoSize), buf);\n",
        "method_start_line": 45,
        "method_end_line": 231
    },
    "96_src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java": {
        "context": "    public void finish() throws IOException {\n        if (!closed) {\n            closed = true;\n            try {\n                if (this.runLength > 0) {\n                    writeRun();\n                }\n                this.currentChar = -1;\n                endBlock();\n                endCompression();\n            } finally {\n                this.out = null;\n                this.blockSorter = null;\n                this.data = null;\n            }\n        }\n    }\n",
        "start_line": 563,
        "end_line": 564,
        "bug_id": "96",
        "before": "    public void finish() throws IOException {\n        if (!closed) {\n            closed = true;\n            try {\n                if (this.runLength > 0) {\n                    writeRun();\n                }\n                this.currentChar = -1;\n                endBlock();\n                endCompression();\n            } finally {\n",
        "after": "                this.blockSorter = null;\n                this.data = null;\n            }\n        }\n    }\n",
        "buggy_line": "this.out = null;",
        "buggy_lines": "                this.out = null;\n",
        "method_start_line": 552,
        "method_end_line": 569
    },
    "98_src/main/java/org/apache/commons/io/input/BufferedFileChannelInputStream.java": {
        "context": "    @Override\n    public synchronized int available() throws IOException {\n        if (!refill()) {\n            return EOF;\n        }\n        return byteBuffer.remaining();\n    }\n",
        "start_line": 172,
        "end_line": 172,
        "bug_id": "98",
        "before": "    @Override\n    public synchronized int available() throws IOException {\n",
        "after": "        if (!refill()) {\n            return EOF;\n        }\n        return byteBuffer.remaining();\n    }\n",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 170,
        "method_end_line": 177
    },
    "4_src/main/java/org/logicng/explanations/smus/SmusComputation.java": {
        "context": "    public static <P extends Proposition> List<P> computeSmus(final List<P> propositions, final List<Formula> additionalConstraints, final FormulaFactory f,\n                                                              final OptimizationHandler handler) {\n        start(handler);\n        final SATSolver growSolver = MiniSat.miniSat(f);\n        growSolver.add(additionalConstraints == null ? Collections.singletonList(f.verum()) : additionalConstraints);\n        final Map<Variable, P> propositionMapping = new TreeMap<>();\n        for (final P proposition : propositions) {\n            final Variable selector = f.variable(PROPOSITION_SELECTOR + propositionMapping.size());\n            propositionMapping.put(selector, proposition);\n            growSolver.add(f.equivalence(selector, proposition.formula()));\n        }\n        final boolean sat = growSolver.sat(satHandler(handler), propositionMapping.keySet()) == Tristate.TRUE;\n        if (aborted(handler)) {\n            return null;\n        }\n        if (sat) {\n            throw new IllegalArgumentException(\"Cannot compute a smallest MUS for a satisfiable formula set.\");\n        }\n        final SATSolver hSolver = MiniSat.miniSat(f);\n        while (true) {\n            final SortedSet<Variable> h = minimumHs(hSolver, propositionMapping.keySet(), handler);\n            if (aborted(handler)) {\n                return null;\n            }\n            final SortedSet<Variable> c = grow(growSolver, h, propositionMapping.keySet(), handler);\n            if (aborted(handler)) {\n                return null;\n            }\n            if (c == null) {\n                return h.stream().map(propositionMapping::get).collect(Collectors.toList());\n            }\n            hSolver.add(f.or(c));\n        }\n    }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "4",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 101,
        "method_end_line": 135
    },
    "11_src/main/java/org/springframework/data/mapping/model/KotlinCopyMethod.java": {
        "context": "\tprivate static boolean isAssignableFrom(Class<?> target, KType source) {\n\n\t\tType parameterType = ReflectJvmMapping.getJavaType(source);\n\n\t\tif (parameterType instanceof Class) {\n\t\t\treturn target.isAssignableFrom((Class<?>) parameterType);\n\t\t}\n\n\t\treturn false;\n\t}\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "11",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 276,
        "method_end_line": 286
    },
    "15_src/main/java/com/amihaiemil/eoyaml/FirstCommentFound.java": {
        "context": "    private Iterator<YamlLine> nodeComment() {\n        enteredComments = false;\n        Iterator<YamlLine> iterator = this.lines.iterator();\n        final List<YamlLine> comment = new ArrayList<>();\n        while (iterator.hasNext()) {\n            final YamlLine line = iterator.next();\n            boolean hasComment = !line.comment().isEmpty();\n            if (enteredComments && !hasComment) {\n                break;\n            } else {\n                if (hasComment) {\n                    enteredComments = true;\n                    if (!\"---\".equals(line.trimmed())) {\n                        if (line.trimmed().startsWith(\"#\")) {\n                            comment.add(line);\n                        }\n                    }\n                }\n            }\n        }\n        iterator = comment.iterator();\n        return iterator;\n    }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "15",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 118,
        "method_end_line": 141
    },
    "16_src/main/java/nonapi/io/github/classgraph/fileslice/reader/ClassfileReader.java": {
        "context": "    private void readTo(final int targetArrUsed) throws IOException {\n        // Array does not need to grow larger than the length hint (if the uncompressed size of the zip entry\n        // is an underestimate, classfile will be truncated). If -1, assume 2GB is the max size.\n        final int maxArrLen = classfileLengthHint == -1 ? FileUtils.MAX_BUFFER_SIZE : classfileLengthHint;\n        if (inflaterInputStream == null && randomAccessReader == null) {\n            // If neither inflaterInputStream nor randomAccessReader is set, then slice is an ArraySlice,\n            // and array is already \"fully loaded\" (the ArraySlice's backing array is used as the buffer).\n            throw new IOException(\"Tried to read past end of fixed array buffer\");\n        }\n        if (targetArrUsed > FileUtils.MAX_BUFFER_SIZE || targetArrUsed < 0 || arrUsed == maxArrLen) {\n            throw new IOException(\"Hit 2GB limit while trying to grow buffer array\");\n        }\n\n        // Need to read at least BUF_CHUNK_SIZE (but don't overshoot past 2GB limit)\n        final int maxNewArrUsed = (int) Math.min(Math.max(targetArrUsed, (long) (arrUsed + BUF_CHUNK_SIZE)),\n                maxArrLen);\n\n        // Double the size of the array if it's too small to contain the new chunk of bytes\n        if (arr.length < maxNewArrUsed) {\n            arr = Arrays.copyOf(arr, (int) Math.min(arr.length * 2L, maxArrLen));\n        }\n\n        // Figure out the maximum number of bytes that can be read into the array (which is the minimum\n        // of the number of requested bytes, and the space left in the array)\n        final int maxBytesToRead = Math.min(maxNewArrUsed - arrUsed, arr.length - arrUsed);\n\n        // Read a new chunk into the buffer, starting at position arrUsed\n        if (inflaterInputStream != null) {\n            // Read from inflater input stream\n            final int numRead = inflaterInputStream.read(arr, arrUsed, maxBytesToRead);\n            if (numRead > 0) {\n                arrUsed += numRead;\n            }\n        } else /* randomAccessReader == null, so this is a (non-deflated) FileSlice */ {\n            // Don't read past end of slice\n            final int bytesToRead = Math.min(maxBytesToRead, maxArrLen - arrUsed);\n            // Read bytes from FileSlice into arr\n            final int numBytesRead = randomAccessReader.read(/* srcOffset = */ arrUsed, /* dstArr = */ arr,\n                    /* dstArrStart = */ arrUsed, /* numBytes = */ bytesToRead);\n            if (numBytesRead > 0) {\n                arrUsed += numBytesRead;\n            }\n        }\n\n        // Check the buffer was able to be filled to the requested position\n        if (arrUsed < targetArrUsed) {\n            throw new IOException(\"Buffer underflow\");\n        }\n    }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "16",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 163,
        "method_end_line": 212
    },
    "18_src/main/java/com/alibaba/fastjson/parser/JSONLexerBase.java": {
        "context": "    public BigInteger scanFieldBigInteger(char[] fieldName) {\n        matchStat = UNKNOWN;\n\n        if (!charArrayCompare(fieldName)) {\n            matchStat = NOT_MATCH_NAME;\n            return null;\n        }\n\n        int offset = fieldName.length;\n        char chLocal = charAt(bp + (offset++));\n        final boolean quote = chLocal == '\"';\n        if (quote) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        boolean negative = chLocal == '-';\n        if (negative) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        BigInteger value;\n        if (chLocal >= '0' && chLocal <= '9') {\n            long intVal = chLocal - '0';\n            for (;;) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal >= '0' && chLocal <= '9') {\n                    intVal = intVal * 10 + (chLocal - '0');\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            int start, count;\n            if (quote) {\n                if (chLocal != '\"') {\n                    matchStat = NOT_MATCH;\n                    return null;\n                } else {\n                    chLocal = charAt(bp + (offset++));\n                }\n                start = bp + fieldName.length + 1;\n                count = bp + offset - start - 2;\n            } else {\n                start = bp + fieldName.length;\n                count = bp + offset - start - 1;\n            }\n\n            if (count < 20 || (negative && count < 21)) {\n                value = BigInteger.valueOf(negative ? -intVal : intVal);\n            } else {\n\n//            char[] chars = this.sub_chars(negative ? start + 1 : start, count);\n//            value = new BigInteger(chars, )\n                String strVal = this.subString(start, count);\n                value = new BigInteger(strVal);\n            }\n        } else if (chLocal == 'n' &&\n                   charAt(bp + offset) == 'u' &&\n                   charAt(bp + offset + 1) == 'l' &&\n                   charAt(bp + offset + 2) == 'l') {\n            matchStat = VALUE_NULL;\n            value = null;\n            offset += 3;\n            chLocal = charAt(bp + offset++);\n\n            if (quote && chLocal == '\"') {\n                chLocal = charAt(bp + offset++);\n            }\n\n            for (;;) {\n                if (chLocal == ',') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.COMMA;\n                    return value;\n                } else if (chLocal == '}') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.RBRACE;\n                    return value;\n                } else if (isWhitespace(chLocal)) {\n                    chLocal = charAt(bp + offset++);\n                    continue;\n                }\n                break;\n            }\n            matchStat = NOT_MATCH;\n            return null;\n        } else {\n            matchStat = NOT_MATCH;\n            return null;\n        }\n\n        if (chLocal == ',') {\n            bp += offset;\n            this.ch = this.charAt(bp);\n            matchStat = VALUE;\n            token = JSONToken.COMMA;\n            return value;\n        }\n\n        if (chLocal == '}') {\n            chLocal = charAt(bp + (offset++));\n            if (chLocal == ',') {\n                token = JSONToken.COMMA;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == ']') {\n                token = JSONToken.RBRACKET;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == '}') {\n                token = JSONToken.RBRACE;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == EOI) {\n                token = JSONToken.EOF;\n                bp += (offset - 1);\n                ch = EOI;\n            } else {\n                matchStat = NOT_MATCH;\n                return null;\n            }\n            matchStat = END;\n        } else {\n            matchStat = NOT_MATCH;\n            return null;\n        }\n\n        return value;\n    }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "18",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 3790,
        "method_end_line": 3924
    },
    "26_src/main/java/com/github/davidmoten/rtree/internal/Util.java": {
        "context": "    public static Rectangle mbr(Collection<? extends HasGeometry> items) {\n        Preconditions.checkArgument(!items.isEmpty());\n        double minX1 = Double.MAX_VALUE;\n        double minY1 = Double.MAX_VALUE;\n        double maxX2 = -Double.MAX_VALUE;\n        double maxY2 = -Double.MAX_VALUE;\n        for (final HasGeometry item : items) {\n            Rectangle r = item.geometry().mbr();\n            if (r.x1() < minX1)\n                minX1 = r.x1();\n            if (r.y1() < minY1)\n                minY1 = r.y1();\n            if (r.x2() > maxX2)\n                maxX2 = r.x2();\n            if (r.y2() > maxY2)\n                maxY2 = r.y2();\n        }\n        return Geometries.rectangle(minX1, minY1, maxX2, maxY2);\n    }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "26",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 43,
        "method_end_line": 62
    },
    "50_src/main/java/org/apache/commons/jexl3/internal/Scope.java": {
        "context": "        public Frame assign(Object... values) {\n            if (stack != null && values != null && values.length > 0) {\n                int nparm = scope.getArgCount();\n                Object[] copy = stack.clone();\n                int ncopy = Math.min(nparm - curried, Math.min(nparm, values.length));\n                System.arraycopy(values, 0, copy, curried, ncopy);\n                return new Frame(scope, copy, curried + ncopy);\n            }\n            return this;\n        }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "50",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 399,
        "method_end_line": 409
    },
    "59_src/main/java/com/esri/core/geometry/ogc/OGCConcreteGeometryCollection.java": {
        "context": "\t@Override\n\tpublic OGCGeometry convexHull() {\n\t\tGeometryCursor cursor = OperatorConvexHull.local().execute(\n\t\t\t\tgetEsriGeometryCursor(), false, null);\n\t\tMultiPoint mp = new MultiPoint();\n\t\tPolygon polygon = new Polygon();\n\t\tVertexDescription vd = null;\n\t\tfor (Geometry geom = cursor.next(); geom != null; geom = cursor.next()) {\n\t\t\tvd = geom.getDescription();\n\t\t\tif (geom.isEmpty())\n\t\t\t\tcontinue;\n\n\t\t\tif (geom.getType() == Geometry.Type.Polygon) {\n\t\t\t\tpolygon.add((MultiPath) geom, false);\n\t\t\t}\n\t\t\telse if (geom.getType() == Geometry.Type.Polyline) {\n\t\t\t\tmp.add((MultiVertexGeometry) geom, 0, -1);\n\t\t\t}\n\t\t\telse if (geom.getType() == Geometry.Type.Point) {\n\t\t\t\tmp.add((Point) geom);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new GeometryException(\"internal error\");\n\t\t\t}\n\t\t}\n\n\t\tGeometry resultGeom = null;\n\t\tif (!mp.isEmpty()) {\n\t\t\tresultGeom = OperatorConvexHull.local().execute(mp, null);\n\t\t}\n\n\t\tif (!polygon.isEmpty()) {\n\t\t\tif (!resultGeom.isEmpty()) {\n\t\t\t\tGeometry[] geoms = { resultGeom, polygon };\n\t\t\t\tresultGeom = OperatorConvexHull.local().execute(\n\t\t\t\t\t\tnew SimpleGeometryCursor(geoms), true, null).next();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresultGeom = polygon;\n\t\t\t}\n\t\t}\n\n\t\tif (resultGeom == null) {\n\t\t\tPoint pt = new Point();\n\t\t\tif (vd != null)\n\t\t\t\tpt.assignVertexDescription(vd);\n\n\t\t\treturn new OGCPoint(pt, getEsriSpatialReference());\n\t\t}\n\n\t\treturn OGCGeometry.createFromEsriGeometry(resultGeom, getEsriSpatialReference(), false);\n\t}\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "59",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 415,
        "method_end_line": 467
    },
    "62_src/main/java/org/cactoos/func/RepeatedFunc.java": {
        "context": "    @Override\n    public Y apply(final X input) throws Exception {\n        Y result = null;\n        for (int idx = 0; idx < this.times; ++idx) {\n            result = this.func.apply(input);\n        }\n        if (result == null) {\n            throw new IllegalArgumentException(\n                new FormattedText(\n                    \"Repeat counter is equal or less than zero: %d\",\n                    this.times\n                ).asString()\n            );\n        }\n        return result;\n    }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "62",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 76,
        "method_end_line": 92
    },
    "64_src/main/java/com/alibaba/fastjson/parser/JavaBeanDeserializer.java": {
        "context": "    private boolean parseField(DefaultJSONParser parser, String key, Object object, Type objectType,\n                              Map<String, Object> fieldValues) {\n        JSONLexer lexer = parser.lexer; // xxx\n\n        FieldDeserializer fieldDeserializer = getFieldDeserializer(key);\n\n        if (fieldDeserializer == null) {\n            long smartKeyHash = TypeUtils.fnv_64_lower(key);\n            if (this.smartMatchHashArray == null) {\n                long[] hashArray = new long[sortedFieldDeserializers.length];\n                for (int i = 0; i < sortedFieldDeserializers.length; i++) {\n                    hashArray[i] = TypeUtils.fnv_64_lower(sortedFieldDeserializers[i].fieldInfo.name);\n                }\n                Arrays.sort(hashArray);\n                this.smartMatchHashArray = hashArray;\n            }\n\n            // smartMatchHashArrayMapping\n\n            int pos = Arrays.binarySearch(smartMatchHashArray, smartKeyHash);\n            if (pos < 0 && key.startsWith(\"is\")) {\n                smartKeyHash = TypeUtils.fnv_64_lower(key.substring(2));\n                pos = Arrays.binarySearch(smartMatchHashArray, smartKeyHash);\n            }\n\n            if (pos >= 0) {\n                if (smartMatchHashArrayMapping == null) {\n                    int[] mapping = new int[smartMatchHashArray.length];\n                    Arrays.fill(mapping, -1);\n                    for (int i = 0; i < sortedFieldDeserializers.length; i++) {\n                        int p = Arrays.binarySearch(smartMatchHashArray\n                                , TypeUtils.fnv_64_lower(sortedFieldDeserializers[i].fieldInfo.name));\n                        if (p >= 0) {\n                            mapping[p] = i;\n                        }\n                    }\n                    smartMatchHashArrayMapping = mapping;\n                }\n\n                int deserIndex = smartMatchHashArrayMapping[pos];\n                if (deserIndex != -1) {\n                    fieldDeserializer = sortedFieldDeserializers[deserIndex];\n                }\n            }\n        }\n\n        final int mask = Feature.SupportNonPublicField.mask;\n        if (fieldDeserializer == null\n                && ((parser.lexer.features & mask) != 0\n                    || (this.beanInfo.parserFeatures & mask) != 0)) {\n            if (this.extraFieldDeserializers == null) {\n                ConcurrentHashMap extraFieldDeserializers = new ConcurrentHashMap<String, Object>(1, 0.75f, 1);\n                for (Class c = this.clazz; c != null && c != Object.class; c = c.getSuperclass()) {\n                    Field[] fields = c.getDeclaredFields();\n                    for (Field field : fields) {\n                        String fieldName = field.getName();\n                        if (this.getFieldDeserializer(fieldName) != null) {\n                            continue;\n                        }\n                        int fieldModifiers = field.getModifiers();\n                        if ((fieldModifiers & Modifier.FINAL) != 0 || (fieldModifiers & Modifier.STATIC) != 0) {\n                            continue;\n                        }\n                        extraFieldDeserializers.put(fieldName, field);\n                    }\n                }\n                this.extraFieldDeserializers = extraFieldDeserializers;\n            }\n\n            Object deserOrField = extraFieldDeserializers.get(key);\n            if (deserOrField != null) {\n                if (deserOrField instanceof FieldDeserializer) {\n                    fieldDeserializer = ((FieldDeserializer) deserOrField);\n                } else {\n                    Field field = (Field) deserOrField;\n                    field.setAccessible(true);\n                    FieldInfo fieldInfo = new FieldInfo(key, field.getDeclaringClass(), field.getType(), field.getGenericType(), field, 0, 0);\n                    fieldDeserializer = new DefaultFieldDeserializer(parser.config, clazz, fieldInfo);\n                    extraFieldDeserializers.put(key, fieldDeserializer);\n                }\n            }\n        }\n\n        if (fieldDeserializer == null) {\n            parseExtra(parser, object, key);\n\n            return false;\n        }\n\n        lexer.nextTokenWithChar(':');\n\n        fieldDeserializer.parseField(parser, object, objectType, fieldValues);\n\n        return true;\n    }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "64",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 912,
        "method_end_line": 1007
    },
    "69_src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java": {
        "context": "    public Object createInstance(Map<String, Object> map, ParserConfig config) //\n                                                                               throws IllegalArgumentException,\n                                                                               IllegalAccessException,\n                                                                               InvocationTargetException {\n        Object object = null;\n        \n        if (beanInfo.creatorConstructor == null && beanInfo.factoryMethod == null) {\n            object = createInstance(null, clazz);\n            \n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser == null) {\n                    continue;\n                }\n\n                final FieldInfo fieldInfo = fieldDeser.fieldInfo;\n                Field field = fieldDeser.fieldInfo.field;\n                Type paramType = fieldInfo.fieldType;\n\n                if (field != null) {\n                    if (paramType == boolean.class) {\n                        if (value == Boolean.FALSE) {\n                            field.setBoolean(object, false);\n                            continue;\n                        }\n\n                        if (value == Boolean.TRUE) {\n                            field.setBoolean(object, true);\n                            continue;\n                        }\n                    } else if (paramType == int.class) {\n                        if (value instanceof Number) {\n                            field.setInt(object, ((Number) value).intValue());\n                            continue;\n                        }\n                    } else if (paramType == long.class) {\n                        if (value instanceof Number) {\n                            field.setLong(object, ((Number) value).longValue());\n                            continue;\n                        }\n                    } else if (paramType == float.class) {\n                        if (value instanceof Number) {\n                            field.setFloat(object, ((Number) value).floatValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            float floatValue;\n                            if (strVal.length() <= 10) {\n                                floatValue = TypeUtils.parseFloat(strVal);\n                            } else {\n                                floatValue = Float.parseFloat(strVal);\n                            }\n\n                            field.setFloat(object, floatValue);\n                            continue;\n                        }\n                    } else if (paramType == double.class) {\n                        if (value instanceof Number) {\n                            field.setDouble(object, ((Number) value).doubleValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            double doubleValue;\n                            if (strVal.length() <= 10) {\n                                doubleValue = TypeUtils.parseDouble(strVal);\n                            } else {\n                                doubleValue = Double.parseDouble(strVal);\n                            }\n\n                            field.setDouble(object, doubleValue);\n                            continue;\n                        }\n                    } else if (value != null && paramType == value.getClass()) {\n                        field.set(object, value);\n                        continue;\n                    }\n                }\n\n                String format = fieldInfo.format;\n                if (format != null && paramType == java.util.Date.class) {\n                    value = TypeUtils.castToDate(value, format);\n                } else {\n                    if (paramType instanceof ParameterizedType) {\n                        value = TypeUtils.cast(value, (ParameterizedType) paramType, config);\n                    } else {\n                        value = TypeUtils.cast(value, paramType, config);\n                    }\n                }\n\n                fieldDeser.setValue(object, value);\n            }\n\n            if (beanInfo.buildMethod != null) {\n                Object builtObj;\n                try {\n                    builtObj = beanInfo.buildMethod.invoke(object);\n                } catch (Exception e) {\n                    throw new JSONException(\"build object error\", e);\n                }\n\n                return builtObj;\n            }\n\n            return object;\n        }\n\n        \n        FieldInfo[] fieldInfoList = beanInfo.fields;\n        int size = fieldInfoList.length;\n        Object[] params = new Object[size];\n        Map<String, Integer> missFields = null;\n        for (int i = 0; i < size; ++i) {\n            FieldInfo fieldInfo = fieldInfoList[i];\n            Object param = map.get(fieldInfo.name);\n\n            if (param == null) {\n                Class<?> fieldClass = fieldInfo.fieldClass;\n                if (fieldClass == int.class) {\n                    param = 0;\n                } else if (fieldClass == long.class) {\n                    param = 0L;\n                } else if (fieldClass == short.class) {\n                    param = Short.valueOf((short) 0);\n                } else if (fieldClass == byte.class) {\n                    param = Byte.valueOf((byte) 0);\n                } else if (fieldClass == float.class) {\n                    param = Float.valueOf(0);\n                } else if (fieldClass == double.class) {\n                    param = Double.valueOf(0);\n                } else if (fieldClass == char.class) {\n                    param = '0';\n                } else if (fieldClass == boolean.class) {\n                    param = false;\n                }\n                if (missFields == null) {\n                    missFields = new HashMap<String, Integer>();\n                }\n                missFields.put(fieldInfo.name, i);\n            }\n            params[i] = param;\n        }\n\n        if (missFields != null) {\n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser != null) {\n                    Integer index = missFields.get(fieldDeser.fieldInfo.name);\n                    if (index != null) {\n                        params[index] = value;\n                    }\n                }\n            }\n        }\n\n        if (beanInfo.creatorConstructor != null) {\n            boolean hasNull = false;\n            if (beanInfo.kotlin) {\n                for (int i = 0; i < params.length; i++) {\n                    if (params[i] == null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                        FieldInfo fieldInfo = beanInfo.fields[i];\n                        if (fieldInfo.fieldClass == String.class) {\n                            hasNull = true;\n                        }\n                        break;\n                    }\n                }\n            }\n\n            if (hasNull && beanInfo.kotlinDefaultConstructor != null) {\n                try {\n                    object = beanInfo.kotlinDefaultConstructor.newInstance();\n\n                    for (int i = 0; i < params.length; i++) {\n                        final Object param = params[i];\n                        if (param != null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                            FieldInfo fieldInfo = beanInfo.fields[i];\n                            fieldInfo.set(object, param);\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            } else {\n                try {\n                    object = beanInfo.creatorConstructor.newInstance(params);\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            }\n        } else if (beanInfo.factoryMethod != null) {\n            try {\n                object = beanInfo.factoryMethod.invoke(null, params);\n            } catch (Exception e) {\n                throw new JSONException(\"create factory method error, \" + beanInfo.factoryMethod.toString(), e);\n            }\n        }\n        \n        return object;\n    }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "69",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 1315,
        "method_end_line": 1522
    },
    "70_src/main/java/com/alibaba/fastjson/util/FieldInfo.java": {
        "context": "    private static Type getInheritGenericType(Class<?> clazz, Type type, TypeVariable<?> tv) {\n        Class<?> gd = (Class<?>) tv.getGenericDeclaration();\n\n        Type[] arguments = null;\n        if (gd == clazz) {\n            if (type instanceof ParameterizedType) {\n                ParameterizedType ptype = (ParameterizedType) type;\n                arguments = ptype.getActualTypeArguments();\n            }\n        } else {\n            for (Class<?> c = clazz; c != null && c != Object.class && c != gd; c = c.getSuperclass()) {\n                Type superType = c.getGenericSuperclass();\n\n                if (superType instanceof ParameterizedType) {\n                    ParameterizedType p_superType = (ParameterizedType) superType;\n                    Type[] p_superType_args = p_superType.getActualTypeArguments();\n                    getArgument(p_superType_args, c.getTypeParameters(), arguments);\n                    arguments = p_superType_args;\n                }\n            }\n        }\n\n        if (arguments == null) {\n            return null;\n        }\n\n        Type actualType = null;\n        TypeVariable<?>[] typeVariables = gd.getTypeParameters();\n        for (int j = 0; j < typeVariables.length; ++j) {\n            if (tv.equals(typeVariables[j])) {\n                actualType = arguments[j];\n                break;\n            }\n        }\n\n        return actualType;\n    }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "70",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 345,
        "method_end_line": 382
    },
    "71_src/main/java/com/alibaba/fastjson/parser/JSONScanner.java": {
        "context": "    public boolean scanFieldBoolean(char[] fieldName) {\n        matchStat = UNKNOWN;\n\n        if (!charArrayCompare(text, bp, fieldName)) {\n            matchStat = NOT_MATCH_NAME;\n            return false;\n        }\n\n        int index = bp + fieldName.length;\n\n        char ch = charAt(index++);\n\n        final boolean quote = ch == '\"';\n        if (quote) {\n            ch = charAt(index++);\n        }\n\n        boolean value;\n        if (ch == 't') {\n            if (charAt(index++) != 'r') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 'u') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 'e') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            if (quote && charAt(index++) != '\"') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            bp = index;\n            ch = charAt(bp);\n            value = true;\n        } else if (ch == 'f') {\n            if (charAt(index++) != 'a') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 'l') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 's') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 'e') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            if (quote && charAt(index++) != '\"') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            bp = index;\n            ch = charAt(bp);\n            value = false;\n        } else if (ch == '1') {\n                if (quote && charAt(index++) != '\"') {\n                    matchStat = NOT_MATCH;\n                    return false;\n                }\n\n                bp = index;\n                ch = charAt(bp);\n                value = true;\n        } else if (ch == '0') {\n            if (quote && charAt(index++) != '\"') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            bp = index;\n            ch = charAt(bp);\n            value = false;\n        } else {\n            matchStat = NOT_MATCH;\n            return false;\n        }\n\n        for (;;) {\n            if (ch == ',') {\n                this.ch = charAt(++bp);\n                matchStat = VALUE;\n                token = JSONToken.COMMA;\n                break;\n            } else if (ch == '}') {\n                ch = charAt(++bp);\n                for (;;) {\n                    if (ch == ',') {\n                        token = JSONToken.COMMA;\n                        this.ch = charAt(++bp);\n                    } else if (ch == ']') {\n                        token = JSONToken.RBRACKET;\n                        this.ch = charAt(++bp);\n                    } else if (ch == '}') {\n                        token = JSONToken.RBRACE;\n                        this.ch = charAt(++bp);\n                    } else if (ch == EOI) {\n                        token = JSONToken.EOF;\n                    } else if (isWhitespace(ch)) {\n                        ch = charAt(++bp);\n                        continue;\n                    } else {\n                        matchStat = NOT_MATCH;\n                        return false;\n                    }\n                    break;\n                }\n                matchStat = END;\n                break;\n            } else if (isWhitespace(ch)) {\n                ch = charAt(++bp);\n            } else {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n        }\n\n        return value;\n    }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "71",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 1433,
        "method_end_line": 1563
    },
    "78_src/main/java/org/springframework/hateoas/server/mvc/WebMvcLinkBuilderFactory.java": {
        "context": "\t@SuppressWarnings(\"null\")\n\tprivate Supplier<ConversionService> getConversionService() {\n\n\t\treturn () -> {\n\n\t\t\tRequestAttributes attributes = RequestContextHolder.getRequestAttributes();\n\n\t\t\tif (!ServletRequestAttributes.class.isInstance(attributes)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tServletContext servletContext = ((ServletRequestAttributes) attributes).getRequest().getServletContext();\n\t\t\tWebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext);\n\n\t\t\treturn context == null || !context.containsBean(\"mvcConversionService\")\n\t\t\t\t\t? FALLBACK_CONVERSION_SERVICE\n\t\t\t\t\t: context.getBean(\"mvcConversionService\", ConversionService.class);\n\t\t};\n\t}\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "78",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 151,
        "method_end_line": 170
    },
    "83_java/src/com/google/template/soy/passes/CombineConsecutiveRawTextNodesPass.java": {
        "context": "  @SuppressWarnings(\"unchecked\")\n  private int mergeRange(ParentSoyNode<?> parent, int start, int lastNonEmptyRawTextNode, int end) {\n    checkArgument(start < end);\n    if (start == -1 || end == start + 1) {\n      return end;\n    }\n    // general case, there are N rawtextnodes to merge where n > 1\n    // merge all the nodes together, then drop all the raw text nodes from the end\n    RawTextNode newNode =\n        RawTextNode.concat(\n            (List<RawTextNode>) parent.getChildren().subList(start, lastNonEmptyRawTextNode + 1));\n    ((ParentSoyNode) parent).replaceChild(start, newNode);\n    for (int i = end - 1; i > start; i--) {\n      parent.removeChild(i);\n    }\n    return start + 1;\n  }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "83",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 96,
        "method_end_line": 113
    },
    "85_java/src/com/google/template/soy/jssrc/internal/TranslateExprNodeVisitor.java": {
        "context": "  @Override\n  protected Expression visitVeLiteralNode(VeLiteralNode node) {\n    ValidatedLoggableElement element = node.getLoggableElement();\n    Expression metadata;\n    if (element.hasMetadata()) {\n      metadata =\n          GoogRequire.create(element.getJsPackage())\n              .googModuleGet()\n              .dotAccess(element.getClassName())\n              .dotAccess(element.getGeneratedVeMetadataMethodName())\n              .call();\n    } else {\n      metadata = Expression.LITERAL_UNDEFINED;\n    }\n    return Expression.ifExpression(\n            GOOG_DEBUG,\n            construct(\n                SOY_VISUAL_ELEMENT,\n                Expression.number(node.getId()),\n                metadata,\n                Expression.stringLiteral(node.getName().identifier())))\n        .setElse(construct(SOY_VISUAL_ELEMENT, Expression.number(node.getId()), metadata))\n        .build(codeGenerator);\n  }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "85",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 974,
        "method_end_line": 998
    },
    "94_src/main/java/com/blade/mvc/handler/RequestInvoker.java": {
        "context": "    public boolean invokeHook(Signature routeSignature, Route hookRoute) throws Exception {\n        Method hookMethod = hookRoute.getAction();\n        Object target     = hookRoute.getTarget();\n        if (null == target) {\n            Class<?> clazz = hookRoute.getAction().getDeclaringClass();\n            target = ioc.getBean(clazz);\n            hookRoute.setTarget(target);\n        }\n\n        // execute\n        int len = hookMethod.getParameterTypes().length;\n        hookMethod.setAccessible(true);\n\n        Object returnParam;\n        if (len > 0) {\n            returnParam = ReflectKit.invokeMethod(target, hookMethod, routeSignature);\n        } else {\n            returnParam = ReflectKit.invokeMethod(target, hookMethod);\n        }\n\n        if (null == returnParam) return true;\n\n        Class<?> returnType = returnParam.getClass();\n        if (returnType == Boolean.class || returnType == boolean.class) {\n            return Boolean.valueOf(returnParam.toString());\n        }\n        return true;\n    }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "94",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 111,
        "method_end_line": 139
    },
    "99_src/main/java/org/apache/commons/io/FileUtils.java": {
        "context": "    public static void copyFile(final File srcFile, final File destFile, final boolean preserveFileDate, CopyOption... copyOptions) throws IOException {\n        Objects.requireNonNull(destFile, \"destination\");\n        checkFileExists(srcFile, \"srcFile\");\n        requireCanonicalPathsNotEquals(srcFile, destFile);\n        createParentDirectories(destFile);\n        if (destFile.exists()) {\n            checkFileExists(destFile, \"destFile\");\n            requireCanWrite(destFile, \"destFile\");\n        }\n\n        final Path srcPath = srcFile.toPath();\n        final boolean isSymLink = Files.isSymbolicLink(srcPath);\n        if (isSymLink && !Arrays.asList(copyOptions).contains(LinkOption.NOFOLLOW_LINKS)) {\n            final List<CopyOption> list = new ArrayList<>(Arrays.asList(copyOptions));\n            list.add(LinkOption.NOFOLLOW_LINKS);\n            copyOptions = list.toArray(PathUtils.EMPTY_COPY_OPTIONS);\n        }\n\n        Files.copy(srcPath, destFile.toPath(), copyOptions);\n\n        // On Windows, the last modified time is copied by default.\n        if (preserveFileDate && !isSymLink && !setTimes(srcFile, destFile)) {\n            throw new IOException(\"Cannot set the file time.\");\n        }\n    }\n",
        "start_line": 0,
        "end_line": 0,
        "bug_id": "99",
        "before": "",
        "after": "",
        "buggy_line": "",
        "buggy_lines": "",
        "method_start_line": 838,
        "method_end_line": 863
    }
}