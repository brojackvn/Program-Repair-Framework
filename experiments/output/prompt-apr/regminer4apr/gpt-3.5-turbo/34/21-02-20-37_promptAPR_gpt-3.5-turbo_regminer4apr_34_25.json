{
    "0": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        final Map<K, Iterator<?>> iterators = new LinkedHashMap<>(rowData.size());\n        final Map<K, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n        if (headers == null) {\n            if (headerMapping != null) {\n                setHeadersFromMap(headerMapping, true);\n            } else {\n                setHeadersFromMap(rowData, true);\n            }\n            if (isHeaderWritingEnabled && recordCount == 0) {\n                outputList.add(writeHeadersToString());\n            }\n        }\n\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            Iterator<?> iterator = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            iterators.put(rowEntry.getKey(), iterator);\n            rowValues.put(rowEntry.getKey(), null);\n        }\n\n        boolean allNulls;\n        do {\n            allNulls = true;\n            for (Map.Entry<K, Iterator<?>> entry : iterators.entrySet()) {\n                K key = entry.getKey();\n                Iterator<?> iterator = entry.getValue();\n                boolean hasNext = iterator != null && iterator.hasNext();\n                if (hasNext) {\n                    allNulls = false;\n                    rowValues.put(key, iterator.next());\n                } else {\n                    rowValues.put(key, null);\n                }\n            }\n\n            if (!allNulls) {\n                if (outputList == null) {\n                    if (useRowProcessor) {\n                        processRecord(headerMapping, rowValues);\n                    } else {\n                        writeRow(headerMapping, rowValues);\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                }\n            }\n        } while (!allNulls);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1789
        ],
        "status": "[CE]",
        "error_message": [
            "[1734,65] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.8600318431854248
    },
    "1": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator<?>[] iterators = new Iterator[rowData.size()];\n        Object[] keys = new Object[rowData.size()];\n        final Map<Object, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n        if (headerMapping == null) {\n            setHeadersFromMap(rowData, true);\n            if (isHeaderWritingEnabled && rowData.isEmpty()) {\n                outputList.add(writeHeadersToString(headerMapping));\n            }\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n        boolean nullsOnly;\n\n        do {\n            nullsOnly = true;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                boolean isNull = iterator == null || !iterator.hasNext();\n                nullsOnly &= isNull;\n                if (isNull) {\n                    rowValues.put(keys[i], null);\n                } else {\n                    rowValues.put(keys[i], iterator.next());\n                }\n            }\n            if (!nullsOnly) {\n                if (outputList == null) {\n                    if (useRowProcessor) {\n                        processRecord(headerMapping, rowValues);\n                    } else {\n                        writeRow(headerMapping, rowValues);\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                }\n            }\n        } while (!nullsOnly);\n    } catch (Throwable t) {\n        throw new RuntimeException(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1786
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,65] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.9540090560913086
    },
    "2": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator[] iterators = new Iterator[rowData.size()];\n        Object[] keys = new Object[rowData.size()];\n        final Map<Object, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n        if (headerMapping != null) {\n            setHeadersFromMap(headerMapping, true);\n        } else {\n            setHeadersFromMap(rowData, true);\n        }\n\n        if (isHeaderWritingEnabled && recordCount == 0) {\n            outputList.add(writeHeadersToString());\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n\n        boolean hasNonNullValue;\n\n        do {\n            hasNonNullValue = false;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                if (iterator != null && iterator.hasNext()) {\n                    rowValues.put(keys[i], iterator.next());\n                    hasNonNullValue = true;\n                } else {\n                    rowValues.put(keys[i], null);\n                }\n            }\n\n            if (hasNonNullValue) {\n                if (outputList == null) {\n                    if (useRowProcessor) {\n                        processRecord(headerMapping, rowValues);\n                    } else {\n                        writeRow(headerMapping, rowValues);\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                }\n            }\n        } while (hasNonNullValue);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1790
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,65] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.986732006072998
    },
    "3": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n\ttry {\n\t\tIterator<?>[] iterators = new Iterator<?>[rowData.size()];\n\t\tObject[] keys = new Object[rowData.size()];\n\t\tfinal Map<Object, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n\t\tif (headers == null || headers.isEmpty()) {\n\t\t\tif (headerMapping != null) {\n\t\t\t\tsetHeadersFromMap(headerMapping, true);\n\t\t\t} else {\n\t\t\t\tsetHeadersFromMap(rowData, true);\n\t\t\t}\n\t\t\tif (isHeaderWritingEnabled && recordCount == 0 && outputList.isEmpty()) {\n\t\t\t\toutputList.add(writeHeadersToString());\n\t\t\t}\n\t\t}\n\n\t\tint length = 0;\n\t\tfor (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n\t\t\titerators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n\t\t\tkeys[length] = rowEntry.getKey();\n\t\t\trowValues.put(rowEntry.getKey(), null);\n\t\t\tlength++;\n\t\t}\n\n\t\tboolean allNulls;\n\t\tdo {\n\t\t\tallNulls = true;\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tIterator<?> iterator = iterators[i];\n\t\t\t\tboolean isNull = iterator == null || !iterator.hasNext();\n\t\t\t\tallNulls &= isNull;\n\t\t\t\tif (isNull) {\n\t\t\t\t\trowValues.put(keys[i], null);\n\t\t\t\t} else {\n\t\t\t\t\trowValues.put(keys[i], iterator.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!allNulls) {\n\t\t\t\tif (outputList.isEmpty()) {\n\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\tprocessRecord(headerMapping, rowValues);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriteRow(headerMapping, rowValues);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\toutputList.add(processRecordToString(headerMapping, rowValues));\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutputList.add(writeRowToString(headerMapping, rowValues));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!allNulls);\n\t} catch (Throwable t) {\n\t\tthrow throwExceptionAndClose(\"Error processing input rows from map\", t);\n\t}\n}",
        "patched_method_loc": [
            1732,
            1790
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,73] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.8683679103851318
    },
    "4": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator[] iterators = new Iterator[rowData.size()];\n        Object[] keys = new Object[rowData.size()];\n        final Map<K, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n        if (headerMapping == null) {\n            setHeadersFromMap(rowData, true);\n        }\n\n        if (isHeaderWritingEnabled && recordCount == 0) {\n            outputList.add(writeHeadersToString());\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n\n        boolean nullsOnly;\n\n        do {\n            nullsOnly = true;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                boolean isNull = iterator == null || !iterator.hasNext();\n                nullsOnly &= isNull;\n                if (isNull) {\n                    rowValues.put((K) keys[i], null);\n                } else {\n                    rowValues.put((K) keys[i], iterator.next());\n                }\n            }\n\n            if (!nullsOnly) {\n                if (outputList != null) {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        processRecord(headerMapping, rowValues);\n                    } else {\n                        writeRow(headerMapping, rowValues);\n                    }\n                }\n            }\n        } while (!nullsOnly);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1789
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,60] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.9804584980010986
    },
    "5": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        if (headerMapping == null) {\n            throw new IllegalArgumentException(\"headerMapping cannot be null\");\n        }\n\n        final Map<K, Iterator<?>> iterators = new LinkedHashMap<>();\n        final Map<K, Object> rowValues = new LinkedHashMap<>();\n\n        if (headerMapping.isEmpty()) {\n            throw new IllegalArgumentException(\"headerMapping must not be empty\");\n        }\n\n        if (rowData.isEmpty()) {\n            throw new IllegalArgumentException(\"rowData must not be empty\");\n        }\n\n        if (outputList == null) {\n            throw new IllegalArgumentException(\"outputList cannot be null\");\n        }\n\n        if (useRowProcessor && isHeaderWritingEnabled && recordCount == 0) {\n            outputList.add(writeHeadersToString());\n        }\n\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            K key = rowEntry.getKey();\n            I value = rowEntry.getValue();\n\n            if (value == null) {\n                rowValues.put(key, null);\n            } else {\n                Iterator<?> iterator = value.iterator();\n                iterators.put(key, iterator);\n                rowValues.put(key, iterator.hasNext() ? iterator.next() : null);\n            }\n        }\n\n        boolean allNulls = false;\n        do {\n            allNulls = true;\n\n            for (Map.Entry<K, Iterator<?>> entry : iterators.entrySet()) {\n                K key = entry.getKey();\n                Iterator<?> iterator = entry.getValue();\n\n                if (iterator == null || !iterator.hasNext()) {\n                    rowValues.put(key, null);\n                } else {\n                    rowValues.put(key, iterator.next());\n                    allNulls = false;\n                }\n            }\n\n            if (!allNulls) {\n                if (useRowProcessor) {\n                    outputList.add(processRecordToString(headerMapping, rowValues));\n                } else {\n                    outputList.add(writeRowToString(headerMapping, rowValues));\n                }\n            }\n        } while (!allNulls);\n    } catch (Throwable t) {\n        throw new RuntimeException(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1798
        ],
        "status": "[CE]",
        "error_message": [
            "[1738,65] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 124.84524130821228
    },
    "6": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n\ttry {\n\t\tIterator<?>[] iterators = new Iterator<?>[rowData.size()];\n\t\tObject[] keys = new Object[rowData.size()];\n\t\tfinal Map<Object, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n\t\tif (headerMapping == null) {\n\t\t\tsetHeadersFromMap(rowData, true);\n\t\t} else {\n\t\t\tsetHeadersFromMap(headerMapping, true);\n\t\t}\n\n\t\tif (isHeaderWritingEnabled && recordCount == 0) {\n\t\t\toutputList.add(writeHeadersToString());\n\t\t}\n\n\t\tint length = 0;\n\t\tfor (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n\t\t\titerators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n\t\t\tkeys[length] = rowEntry.getKey();\n\t\t\trowValues.put(rowEntry.getKey(), null);\n\t\t\tlength++;\n\t\t}\n\n\t\tboolean nullsOnly;\n\n\t\tdo {\n\t\t\tnullsOnly = true;\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tIterator<?> iterator = iterators[i];\n\t\t\t\tboolean isNull = iterator == null || !iterator.hasNext();\n\t\t\t\tnullsOnly &= isNull;\n\t\t\t\tif (isNull) {\n\t\t\t\t\trowValues.put(keys[i], null);\n\t\t\t\t} else {\n\t\t\t\t\trowValues.put(keys[i], iterator.next());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!nullsOnly) {\n\t\t\t\tif (outputList == null) {\n\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\tprocessRecord(headerMapping, rowValues);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriteRow(headerMapping, rowValues);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\toutputList.add(processRecordToString(headerMapping, rowValues));\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutputList.add(writeRowToString(headerMapping, rowValues));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!nullsOnly);\n\n\t} catch (Throwable t) {\n\t\tthrow throwExceptionAndClose(\"Error processing input rows from map\", t);\n\t}\n}",
        "patched_method_loc": [
            1732,
            1792
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,73] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.9787142276763916
    },
    "7": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator[] iterators = new Iterator[rowData.size()];\n        Object[] keys = new Object[rowData.size()];\n        final Map<Object, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n        if (headerMapping == null) {\n            setHeadersFromMap(rowData, true);\n            if (isHeaderWritingEnabled && recordCount == 0) {\n                outputList.add(writeHeadersToString());\n            }\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n\n        boolean allNulls;\n        do {\n            allNulls = true;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                boolean isNull = iterator == null || !iterator.hasNext();\n                allNulls &= isNull;\n                if (!isNull) {\n                    rowValues.put(keys[i], iterator.next());\n                }\n            }\n            if (!allNulls) {\n                if (outputList != null) {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        processRecord(headerMapping, rowValues);\n                    } else {\n                        writeRow(headerMapping, rowValues);\n                    }\n                }\n            }\n        } while (!allNulls);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1784
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,65] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 2.015960693359375
    },
    "8": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        if (headerMapping == null || rowData == null || outputList == null) {\n            throw new IllegalArgumentException(\"headerMapping, rowData, and outputList must not be null\");\n        }\n\n        if (headerMapping.isEmpty()) {\n            setHeadersFromMap(rowData, true);\n            if (isHeaderWritingEnabled && recordCount == 0) {\n                outputList.add(writeHeadersToString());\n            }\n        }\n\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            K key = rowEntry.getKey();\n            I values = rowEntry.getValue();\n\n            if (values == null) {\n                continue;\n            }\n\n            Iterator<?> iterator = values.iterator();\n            Map<K, Object> rowValues = new LinkedHashMap<>();\n\n            while (iterator.hasNext()) {\n                rowValues.put(key, iterator.next());\n\n                if (!useRowProcessor) {\n                    outputList.add(writeRowToString(headerMapping, rowValues));\n                } else {\n                    outputList.add(processRecordToString(headerMapping, rowValues));\n                }\n            }\n        }\n    } catch (Throwable t) {\n        throw new RuntimeException(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1770
        ],
        "status": "[CE]",
        "error_message": [
            "[1754,58] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.9312357902526855
    },
    "9": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator<?>[] iterators = new Iterator<?>[rowData.size()];\n        Object[] keys = new Object[rowData.size()];\n        final Map<Object, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n        if (headerMapping != null) {\n            setHeadersFromMap(headerMapping, true);\n        } else {\n            setHeadersFromMap(rowData, true);\n        }\n\n        if (isHeaderWritingEnabled && rowData.isEmpty()) {\n            outputList.add(writeHeadersToString());\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n\n        boolean nullsOnly;\n\n        do {\n            nullsOnly = true;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                boolean isNull = iterator == null || !iterator.hasNext();\n                nullsOnly &= isNull;\n                if (isNull) {\n                    rowValues.put(keys[i], null);\n                } else {\n                    rowValues.put(keys[i], iterator.next());\n                }\n            }\n\n            if (!nullsOnly) {\n                if (outputList == null) {\n                    if (useRowProcessor) {\n                        processRecord(headerMapping, rowValues);\n                    } else {\n                        writeRow(headerMapping, rowValues);\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                }\n            }\n        } while (!nullsOnly);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1791
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,65] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 2.0162432193756104
    },
    "10": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator[] iterators = new Iterator[rowData.size()];\n        Object[] keys = new Object[rowData.size()];\n        final Map<Object, Object> rowValues = new LinkedHashMap<Object, Object>(rowData.size());\n\n        if(headerMapping == null){\n            setHeadersFromMap(rowData, true);\n            if(isHeaderWritingEnabled && recordCount == 0){\n                outputList.add(writeHeadersToString());\n            }\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n\n        boolean nullsOnly;\n        do {\n            nullsOnly = true;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                boolean isNull = iterator == null || !iterator.hasNext();\n                nullsOnly &= isNull;\n                if (isNull) {\n                    rowValues.put(keys[i], null);\n                } else {\n                    rowValues.put(keys[i], iterator.next());\n                }\n            }\n\n            if (!nullsOnly && length > 0) {\n                if (outputList == null) {\n                    if (useRowProcessor) {\n                        processRecord(headerMapping, rowValues);\n                    } else {\n                        writeRow(headerMapping, rowValues);\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                }\n            }\n        } while (!nullsOnly && length > 0);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1787
        ],
        "status": "[FE]",
        "error_message": [
            "com.univocity.parsers.issues.github.Github_39#testMapWriting: java.lang.AssertionError: expected [HA,HB,HC,HD,HE"
        ],
        "validation_time": 18.252225399017334
    },
    "11": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n\ttry {\n\t\tIterator<?>[] iterators = new Iterator<?>[rowData.size()];\n\t\tObject[] keys = new Object[rowData.size()];\n\t\tfinal Map<Object, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n\t\tif (headerMapping != null) {\n\t\t\tsetHeadersFromMap(headerMapping, true);\n\t\t} else {\n\t\t\tsetHeadersFromMap(rowData, true);\n\t\t}\n\t\tif (isHeaderWritingEnabled && recordCount == 0) {\n\t\t\toutputList.add(writeHeadersToString());\n\t\t}\n\n\t\tint length = 0;\n\t\tfor (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n\t\t\tIterator<?> iterator = rowEntry.getValue().iterator();\n\t\t\tif (iterator.hasNext()) {\n\t\t\t\titerators[length] = iterator;\n\t\t\t\tkeys[length] = rowEntry.getKey();\n\t\t\t\trowValues.put(rowEntry.getKey(), iterator.next());\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\n\t\tboolean nullsOnly;\n\t\tdo {\n\t\t\tnullsOnly = true;\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tIterator<?> iterator = iterators[i];\n\t\t\t\tboolean isNull = iterator == null || !iterator.hasNext();\n\t\t\t\tnullsOnly &= isNull;\n\t\t\t\tif (!isNull) {\n\t\t\t\t\trowValues.put(keys[i], iterator.next());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!nullsOnly && length > 0) {\n\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\toutputList.add(processRecordToString(headerMapping, rowValues));\n\t\t\t\t} else {\n\t\t\t\t\toutputList.add(writeRowToString(headerMapping, rowValues));\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!nullsOnly && length > 0);\n\t} catch (Throwable t) {\n\t\tthrow throwExceptionAndClose(\"Error processing input rows from map\", t);\n\t}\n}",
        "patched_method_loc": [
            1732,
            1782
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,73] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.8557062149047852
    },
    "12": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n\ttry {\n\t\tIterator<?>[] iterators = new Iterator<?>[rowData.size()];\n\t\tObject[] keys = new Object[rowData.size()];\n\t\tfinal Map<Object, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n\t\tif (headers == null) {\n\t\t\tif (headerMapping != null) {\n\t\t\t\tsetHeadersFromMap(headerMapping, true);\n\t\t\t} else {\n\t\t\t\tsetHeadersFromMap(rowData, true);\n\t\t\t}\n\t\t\tif (isHeaderWritingEnabled && recordCount == 0) {\n\t\t\t\toutputList.add(writeHeadersToString());\n\t\t\t}\n\t\t}\n\n\t\tint length = 0;\n\t\tfor (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n\t\t\titerators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n\t\t\tkeys[length] = rowEntry.getKey();\n\t\t\trowValues.put(rowEntry.getKey(), null);\n\t\t\tlength++;\n\t\t}\n\n\t\tboolean nullsOnly;\n\t\tdo {\n\t\t\tnullsOnly = true;\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tIterator<?> iterator = iterators[i];\n\t\t\t\tboolean isNull = iterator == null || !iterator.hasNext();\n\t\t\t\tnullsOnly &= isNull;\n\t\t\t\tif (isNull) {\n\t\t\t\t\trowValues.put(keys[i], null);\n\t\t\t\t} else {\n\t\t\t\t\trowValues.put(keys[i], iterator.next());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!nullsOnly) {\n\t\t\t\tif (outputList == null) {\n\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\tprocessRecord(headerMapping, rowValues);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriteRow(headerMapping, rowValues);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\toutputList.add(processRecordToString(headerMapping, rowValues));\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutputList.add(writeRowToString(headerMapping, rowValues));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!nullsOnly);\n\t} catch (Throwable t) {\n\t\tthrow throwExceptionAndClose(\"Error processing input rows from map\", t);\n\t}\n}",
        "patched_method_loc": [
            1732,
            1791
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,73] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.8950238227844238
    },
    "13": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator<?>[] iterators = new Iterator<?>[rowData.size()];\n        Object[] keys = new Object[rowData.size()];\n        final Map<Object, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n        if (headerMapping != null) {\n            setHeadersFromMap(headerMapping, true);\n        } else {\n            setHeadersFromMap(rowData, true);\n        }\n\n        if (isHeaderWritingEnabled && recordCount == 0 && outputList != null) {\n            outputList.add(String.join(\",\", headerList));\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n\n        boolean nullsOnly;\n\n        do {\n            nullsOnly = true;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                boolean isNull = iterator == null || !iterator.hasNext();\n                nullsOnly &= isNull;\n                if (isNull) {\n                    rowValues.put(keys[i], null);\n                } else {\n                    rowValues.put(keys[i], iterator.next());\n                }\n            }\n            if (!nullsOnly && outputList != null) {\n                if (useRowProcessor) {\n                    outputList.add(processRecordToString(headerMapping, rowValues));\n                } else {\n                    outputList.add(writeRowToString(headerMapping, rowValues));\n                }\n            }\n        } while (!nullsOnly && length > 0);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1782
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,65] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.8016314506530762
    },
    "14": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator<?>[] iterators = new Iterator<?>[rowData.size()];\n        Object[] keys = new Object[rowData.size()];\n        final Map<Object, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n        if (headerMapping != null) {\n            setHeadersFromMap(headerMapping, true);\n        } else {\n            setHeadersFromMap(rowData, true);\n        }\n        \n        if (isHeaderWritingEnabled && recordCount == 0 && outputList != null) {\n            outputList.add(writeHeadersToString());\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n\n        boolean nullsOnly;\n        do {\n            nullsOnly = true;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                boolean isNull = iterator == null || !iterator.hasNext();\n                nullsOnly &= isNull;\n                if (isNull) {\n                    rowValues.put(keys[i], null);\n                } else {\n                    rowValues.put(keys[i], iterator.next());\n                }\n            }\n            if (!nullsOnly) {\n                if (outputList != null) {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                }\n            }\n        } while (!nullsOnly);\n    } catch (Throwable t) {\n        throw new RuntimeException(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1783
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,65] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.9114902019500732
    },
    "15": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator<?>[] iterators = new Iterator<?>[rowData.size()];\n        Object[] keys = new Object[rowData.size()];\n        final Map<Object, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n        if (headerMapping == null) {\n            setHeadersFromMap(rowData, true);\n            if (isHeaderWritingEnabled && recordCount == 0) {\n                outputList.add(writeHeadersToString());\n            }\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n\n        do {\n            boolean nullsOnly = true;\n            rowValues.clear();\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                boolean isNull = iterator == null || !iterator.hasNext();\n                nullsOnly &= isNull;\n                if (isNull) {\n                    rowValues.put(keys[i], null);\n                } else {\n                    rowValues.put(keys[i], iterator.next());\n                }\n            }\n\n            if (!nullsOnly) {\n                if (outputList == null) {\n                    if (useRowProcessor) {\n                        processRecord(headerMapping, rowValues);\n                    } else {\n                        writeRow(headerMapping, rowValues);\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                }\n            }\n        } while (!nullsOnly);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1787
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,65] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.8421106338500977
    },
    "16": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator[] iterators = new Iterator[rowData.size()];\n        Object[] keys = new Object[rowData.size()];\n        final Map<Object, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n        if (headerMapping != null) {\n            setHeadersFromMap(headerMapping, true);\n        } else {\n            setHeadersFromMap(rowData, true);\n        }\n        if (isHeaderWritingEnabled && rowData.isEmpty()) {\n            outputList.add(writeHeadersToString());\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n        boolean nullsOnly;\n\n        do {\n            nullsOnly = true;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                boolean isNull = iterator == null || !iterator.hasNext();\n                nullsOnly &= isNull;\n                if (isNull) {\n                    rowValues.put(keys[i], null);\n                } else {\n                    rowValues.put(keys[i], iterator.next());\n                }\n            }\n            if (!nullsOnly) {\n                if (outputList == null) {\n                    if (useRowProcessor) {\n                        processRecord(headerMapping, rowValues);\n                    } else {\n                        writeRow(headerMapping, rowValues);\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                }\n            }\n        } while (!nullsOnly);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1788
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,65] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.8402066230773926
    },
    "17": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        if (headerMapping == null || rowData == null || rowData.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid input data\");\n        }\n\n        if (headers == null) {\n            setHeadersFromMap(headerMapping, true);\n            if (isHeaderWritingEnabled && recordCount == 0) {\n                outputList.add(writeHeadersToString());\n            }\n        }\n\n        int length = rowData.size();\n        Iterator<?>[] iterators = new Iterator[length];\n        Object[] keys = new Object[length];\n        final Map<Object, Object> rowValues = new LinkedHashMap<>(length);\n\n        int i = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[i] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[i] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            i++;\n        }\n\n        boolean allNulls;\n        do {\n            allNulls = true;\n            for (int j = 0; j < length; j++) {\n                Iterator<?> iterator = iterators[j];\n                boolean isNull = iterator == null || !iterator.hasNext();\n                allNulls &= isNull;\n                if (isNull) {\n                    rowValues.put(keys[j], null);\n                } else {\n                    rowValues.put(keys[j], iterator.next());\n                }\n            }\n            if (!allNulls) {\n                if (outputList == null) {\n                    if (useRowProcessor) {\n                        processRecord(headerMapping, rowValues);\n                    } else {\n                        writeRow(headerMapping, rowValues);\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                }\n            }\n        } while (!allNulls);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1791
        ],
        "status": "[CE]",
        "error_message": [
            "[1748,65] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.8382008075714111
    },
    "18": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        int length = rowData.size();\n        Object[] keys = new Object[length];\n        final Map<K, Object> rowValues = new LinkedHashMap<>(length);\n\n        if (headerMapping != null) {\n            setHeadersFromMap(headerMapping, true);\n        } else {\n            setHeadersFromMap(rowData, true);\n        }\n\n        if (isHeaderWritingEnabled && recordCount == 0 && outputList != null) {\n            outputList.add(writeHeadersToString());\n        }\n\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            K key = rowEntry.getKey();\n            keys[length - 1] = key;\n            rowValues.put(key, null);\n        }\n\n        boolean nullsOnly;\n\n        do {\n            nullsOnly = true;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = rowData.get(keys[i]) == null ? null : rowData.get(keys[i]).iterator();\n                if (iterator == null || !iterator.hasNext()) {\n                    rowValues.put((K) keys[i], null);\n                } else {\n                    rowValues.put((K) keys[i], iterator.next());\n                    nullsOnly = false;\n                }\n            }\n\n            if (!nullsOnly) {\n                if (outputList == null) {\n                    if (useRowProcessor) {\n                        processRecord(headerMapping, rowValues);\n                    } else {\n                        writeRow(headerMapping, rowValues);\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                }\n            }\n        } while (!nullsOnly);\n    } catch (Throwable t) {\n        throw new RuntimeException(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1788
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,60] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.847994327545166
    },
    "19": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator<?>[] iterators = new Iterator[rowData.size()];\n        Object[] keys = new Object[rowData.size()];\n        final Map<Object, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n        if (headerMapping != null) {\n            setHeadersFromMap(headerMapping, true);\n        } else {\n            setHeadersFromMap(rowData, true);\n        }\n\n        if (isHeaderWritingEnabled && recordCount == 0) {\n            outputList.add(writeHeadersToString());\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n\n        boolean allIteratorsExhausted;\n        do {\n            allIteratorsExhausted = true;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                if (iterator != null && iterator.hasNext()) {\n                    allIteratorsExhausted = false;\n                    rowValues.put(keys[i], iterator.next());\n                } else {\n                    rowValues.put(keys[i], null);\n                }\n            }\n\n            if (!allIteratorsExhausted) {\n                if (outputList != null) {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        processRecord(headerMapping, rowValues);\n                    } else {\n                        writeRow(headerMapping, rowValues);\n                    }\n                }\n            }\n        } while (!allIteratorsExhausted);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1789
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,65] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.8244483470916748
    },
    "20": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator[] iterators = new Iterator[rowData.size()];\n        Object[] keys = new Object[rowData.size()];\n        final Map<K, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n        if (headerMapping != null) {\n            setHeadersFromMap(headerMapping, true);\n        }\n\n        if (isHeaderWritingEnabled && recordCount == 0) {\n            outputList.add(writeHeadersToString());\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n\n        boolean nullsOnly;\n\n        do {\n            nullsOnly = true;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                boolean isNull = iterator == null || !iterator.hasNext();\n                nullsOnly &= isNull;\n                if (isNull) {\n                    rowValues.put((K) keys[i], null);\n                } else {\n                    rowValues.put((K) keys[i], iterator.next());\n                }\n            }\n\n            if (!nullsOnly) {\n                if (outputList == null) {\n                    if (useRowProcessor) {\n                        processRecord(headerMapping, rowValues);\n                    } else {\n                        writeRow(headerMapping, rowValues);\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                }\n            }\n        } while (!nullsOnly);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1789
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,60] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.8106772899627686
    },
    "21": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator[] iterators = new Iterator[rowData.size()];\n        Object[] keys = new Object[rowData.size()];\n        final Map<K, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n        if (headerMapping != null) {\n            setHeadersFromMap(headerMapping, true);\n        } else {\n            setHeadersFromMap(rowData, true);\n        }\n        if (isHeaderWritingEnabled && recordCount == 0) {\n            outputList.add(writeHeadersToString());\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n        \n        boolean nullsOnly;\n        do {\n            nullsOnly = true;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                boolean isNull = iterator == null || !iterator.hasNext();\n                nullsOnly &= isNull;\n                if (isNull) {\n                    rowValues.put((K) keys[i], null);\n                } else {\n                    rowValues.put((K) keys[i], iterator.next());\n                }\n            }\n            if (!nullsOnly) {\n                if (outputList != null) {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        processRecord(headerMapping, rowValues);\n                    } else {\n                        writeRow(headerMapping, rowValues);\n                    }\n                }\n            }\n        } while (!nullsOnly);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1788
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,60] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.8487837314605713
    },
    "22": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator<?>[] iterators = new Iterator[rowData.size()];\n        K[] keys = (K[]) new Object[rowData.size()];\n        final Map<K, Object> rowValues = new LinkedHashMap<>(rowData.size());\n\n        if (headerMapping == null) {\n            setHeadersFromMap(rowData, true);\n        } else {\n            setHeadersFromMap(headerMapping, true);\n        }\n\n        if (isHeaderWritingEnabled && recordCount == 0) {\n            outputList.add(writeHeadersToString());\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n\n        boolean nullsOnly;\n\n        do {\n            nullsOnly = true;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                boolean isNull = iterator == null || !iterator.hasNext();\n                nullsOnly &= isNull;\n                if (isNull) {\n                    rowValues.put(keys[i], null);\n                } else {\n                    rowValues.put(keys[i], iterator.next());\n                }\n            }\n\n            if (!nullsOnly) {\n                if (outputList != null) {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(headerMapping, rowValues));\n                    } else {\n                        outputList.add(writeRowToString(headerMapping, rowValues));\n                    }\n                }\n            }\n        } while (!nullsOnly);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1785
        ],
        "status": "[CE]",
        "error_message": [
            "[1736,60] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.8006858825683594
    },
    "23": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        if (headerMapping == null) {\n            throw new IllegalArgumentException(\"headerMapping cannot be null\");\n        }\n\n        if (rowData == null) {\n            throw new IllegalArgumentException(\"rowData cannot be null\");\n        }\n\n        if (outputList == null) {\n            throw new IllegalArgumentException(\"outputList cannot be null\");\n        }\n\n        if (rowData.isEmpty()) {\n            return;\n        }\n\n        if (headers == null) {\n            setHeadersFromMap(headerMapping, true);\n            if (isHeaderWritingEnabled && recordCount == 0) {\n                outputList.add(writeHeadersToString());\n            }\n        }\n\n        final List<K> keys = new ArrayList<>(rowData.keySet());\n        final Map<K, Iterator<?>> iterators = new HashMap<>();\n        final Map<K, Object> rowValues = new LinkedHashMap<>();\n\n        for (K key : keys) {\n            iterators.put(key, rowData.get(key) == null ? null : rowData.get(key).iterator());\n            rowValues.put(key, null);\n        }\n\n        boolean nullsOnly;\n\n        do {\n            nullsOnly = true;\n            for (K key : keys) {\n                Iterator<?> iterator = iterators.get(key);\n                boolean isNull = iterator == null || !iterator.hasNext();\n                nullsOnly &= isNull;\n                if (isNull) {\n                    rowValues.put(key, null);\n                } else {\n                    rowValues.put(key, iterator.next());\n                }\n            }\n\n            if (!nullsOnly) {\n                if (useRowProcessor) {\n                    outputList.add(processRecordToString(headerMapping, rowValues));\n                } else {\n                    outputList.add(writeRowToString(headerMapping, rowValues));\n                }\n            }\n        } while (!nullsOnly);\n    } catch (Throwable t) {\n        throw new RuntimeException(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1793
        ],
        "status": "[CE]",
        "error_message": [
            "[1757,44] diamond operator is not supported in -source 1.6\n  (use -source 7 or higher to enable diamond operator)"
        ],
        "validation_time": 1.826991081237793
    },
    "24": {
        "patch": "private <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n    try {\n        Iterator[] iterators = new Iterator[rowData.size()];\n        Object[] keys = new Object[rowData.size()];\n        final Map<Object, Object> rowValues = new LinkedHashMap<Object, Object>(rowData.size());\n\n        if (headerMapping == null) {\n            setHeadersFromMap(rowData, true);\n            if (isHeaderWritingEnabled && recordCount == 0) {\n                outputList.add(writeHeadersToString());\n            }\n        }\n\n        int length = 0;\n        for (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n            iterators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n            keys[length] = rowEntry.getKey();\n            rowValues.put(rowEntry.getKey(), null);\n            length++;\n        }\n        boolean nullsOnly;\n\n        do {\n            nullsOnly = true;\n            for (int i = 0; i < length; i++) {\n                Iterator<?> iterator = iterators[i];\n                boolean isNull = iterator == null || !iterator.hasNext();\n                nullsOnly &= isNull;\n                if (isNull) {\n                    rowValues.put(keys[i], null);\n                } else {\n                    rowValues.put(keys[i], iterator.next());\n                }\n            }\n            if (!nullsOnly) {\n                if (outputList != null) {\n                    if (useRowProcessor) {\n                        outputList.add(processRecordToString(rowValues));\n                    } else {\n                        outputList.add(writeRowToString(rowValues));\n                    }\n                } else {\n                    if (useRowProcessor) {\n                        processRecord(rowValues);\n                    } else {\n                        writeRow(rowValues);\n                    }\n                }\n            }\n        } while (!nullsOnly);\n    } catch (Throwable t) {\n        throw throwExceptionAndClose(\"Error processing input rows from map\", t);\n    }\n}",
        "patched_method_loc": [
            1732,
            1786
        ],
        "status": "[FE]",
        "error_message": [
            "com.univocity.parsers.issues.github.Github_39#testMapWriting: java.lang.AssertionError: expected [HA,HB,HC,HD,HE"
        ],
        "validation_time": 18.308029413223267
    }
}